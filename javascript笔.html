<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=-, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
            [1] 运算符 .

             1. 运算符(operator) 也被称为操作符,是用于实现赋值,比较和执行算数运算功能的符号.

             运算符     描述         实例
               +         加        10 + 20 = 30
               -         减        10 - 20 = -10
               *         乘        10 * 20 = 200
               /         除        10 / 20 = 0.5
               %     取余(取模)    得到的数值是除法的余数,例 9 % 2 = 1


               浮点数(小数点)做运算的时候容易出问题 
               例如: console.log(0.1+0.2);
               计算出来的数值并不是 0.3 而是 0.30000000000000004
               从而尽量减少直接用小数参与运算,后面的学习中会有解决的方法
               所以: 不要直接判断两个浮点数之间是否相等.

             2. 该如何判断一个数能够被整除?
                如果他的余数是零就说明这个数可以被整除,这就是%取余运算符的主要作用
                  
             3. 提问 1 + 2 * 3 的结果是多少?
                结果是7,注意算术运算符的优先级,先乘除,后加减,右括号先算括号内的. 

             [2] 表达式和返回值  
                 
                 表达式: 是由数字,运算符,变量等等组成的式子被称为'表达式'

                 只要是'表达式'最终都会有一个结果返回给我们,我们把这个称为'返回值'.

                 例如: var num = 1 + 1;//2 就是返回值
                 正常理解思路为 1 + 1 = num也就是2;
                 但是在程序中是 1 + 1 算出来之后再赋值给 num 所以num的值为 2 ;
                 思路就是把右边的表达式计算完毕把返回值给左边


             [3] 递增和递减运算符概述
                 
             如果需要反复给数字变量添加或减去1,可以使用递增(++)和递减(--)运算符来完成.

             在JavaScript中,递增( ++)和递减( --)既可以放在变量前面，也可以放在变量后面。放在变量前面时，
             我们可以称为前置递增(递减)运算符，放在变量后面时，我们可以称为后置递增（递减）运算符。

            //  注意∶递增和递减运算符必须和变量配合使用。

              1.前置递增运算符++写在变量的前面
               
               var age = 10;
               如果写成++age 就等同于  age = age + 1;

               再比如:
                      var p = 10;
                      console.log(++p + 10);
                      这时候他做了这样的运算
                      ++p 等于 p = 10 + 1
                      然后再加上了 10
                      就等于p = 11 + 10
                      所以log输出的值是 21

              (1) 前置自增和后置自增如果单独使用,其效果是一样的                        
              (2) 后置自增 口诀: 先返回原值,然后再自加.
                
                  例如: var age = 10 ;

                  console.log(age++ + 10);
                  //因为 age++ 是后置自增 , 所以第一步按照后置自增的口诀可以得出
                  //我们可以直接返回 age 自变量的数值等于10,返回完成之后再自加1
                  //这个时候的 age 已经变成了11,但是的计算条件以及用不上 age 的数值了
                  //所以可以直接忽略 age 自增之后的数值,只需要用到 age 之前未自增的10

                  第一部总结: age++ = 10;

                  //第二步再用 c++的数值加上10,也就等于 10 + 10 = 20
                  //所以最终log输出的数值是20

                 案例:
                 var a = 10;
                 ++a;  //a = 11
                 var b = ++a + 2; //++a = ++11 = 12 再加上2,b的值是14 
                 console.log(b);

                 var c = 10;
                 c++;
                 var d = c++ + 2; 
                 console.log(d);
                 //1. 第一步先计算 c++ 的数值,因为 c++ 是后置自增,所以 c 要先返回原数值也就是说
                 //c++ 的值等于10 ,这时候 c++ 的数值已经计算完毕了,所以它再自加一,这个时候
                 //自变量 c 的数值就变成了11 ,等同于 c = 11

                 第一步总结: c++ = 10; c = 11;

                 //2. 第二步再计算 d 第二个条件的 c++ ,因为在第一步的时候 c++的后置自增已经把
                 //c 的自变量数值从10变成了11,所以这个时候的 c++ 就等同于 11++ ,这个时候的
                 //c++就等于11 , c++计算完成之后 c 再加上1 ,所以现在 c = 12 但是c的值现在
                 //已经用不上了,可以忽略

                 第二步总结: c++ = 11;  c = 12;(c的数值可以忽略)  
                 
                 //3. 第三步就是拿第二步 c++的数值再加上2 , 所以也就等于是
                 //11 + 2 = 13

                 var e = 10;
                 var f = e++ + ++e 
                 console.log(f);
                 //1.第一步 e++ 先返回原数值所以 e++ = 10
                 //而 e++ = 10 计算完成之后,这时候的 e 就要再自加1
                 //所以这时候的 e 就变成了11 , e = 11  但是 f 值的第一个条件
                 //并不是需要 e = 11的值,而是 e++ = 10的数值,所以第一步 e++ = 10 计算完成

                 第一步总结: e++ = 10;

                 //2.第二步是计算++e的数值,因为在上一步的计算中 e 的数值已经变成了11
                 //所以第二步是计算e变成11之后的数值 , 因为此时的 e = 11
                 //又因为 ++e = ++11, 所以最后 ++e 的值等于12

                 第二步总结: ++e = 12;

                 //最后合并第一步和第二步的值  f = 10 + 12 = 22;


                [1] 比较运算符
                    
                概念︰比较运算符（关系运算符）是两个数据进行比较时所使用的运算符，
                比较运算后，会返回一个布尔值( true / false )作为比较运算的结果。
              
                运算符名称       说明                      案例          结果
                   <            小于号                     1<2           true
                   >            大于号                     1>2          false
                   >=       大于等于号(大于或者等于)       2 >= 2        true
                   <=       小于等于号(小于或者等于)       3 <= 2        false
                   ==         判等号(会转型)              37 == 37       true
                   !=           不等号                    37 != 37       false
                ===,!==     全等要求值和数据类型都一致    37=== '37'     false

                [1] 逻辑运算符

                概念∶逻辑运算符是用来进行布尔值运算的运算符，其返回值也是布尔值。
                      后面开发中经常用于多个条件的判断
    
                      逻辑运算符             说明                     案例
                        &&         "逻辑与"，简称"与" and        true && false
                        ||         "逻辑或"，简称"或"or          true || false
                        !          "逻辑非"，简称"非" not           ! true     
                        
                1. 逻辑与 &&   and的意思 两侧都为true结果才是 true只要有一侧为false结果就为false
                2. 逻辑或 ||    or的意思 两侧都为false,结果是假false,只要有一侧为真,结果就为真true
                3. 逻辑非 not   !    取反

                [1] 逻辑中断逻辑与

                    1.逻辑与短路运算﹑如果表达式1结果为真则返回表达式2如果表达式1为假那么返回表达式1
                    1.逻辑与
                      语法:表达式1&&表达式2
                      如果第一个表达式的值为真,则返回表达式2如果第一个表达式的值为假,则返回表达式1
                      如果有空的或者否定的为假其余是真的'' null undefined NaN

                [1] 逻辑中断逻辑或

                   逻辑或短路运算如果表达式1结果为真则返回的是表达式1 如果表达式1结果为假则返回表达式2
                   2.逻辑或
                    语法:表达式1表达式2
                    如果第一个表达式的值为真,则返回表达式1如果第一个表达式的值为假,则返回表达式2
                  
                [1] 赋值运算符
                    
                    num++是每次自加一,但是没可能每次都会用自加一,也有可能是自加5,自加6,
                    或者是自加其他的数,就可以这么写
                                             语法: 自加一的写法: num++
                                                   自加6的写法就是 : num += 6;

                [1] 运算符的优先级
                    
                    优先级           运算符           顺序
                      1             小括号            ()
                      2           一元运算符       ++ -- !          
                      3           算术运算符       先 * / % 再 + -
                      4           关系运算符       > >= < <=
                      5           相等运算符       == != === !==
                      6           逻辑运算符       先 && 后 ||
                      7           赋值运算符          = 
                      8           逗号运算符          ,


                [1] 流程控制
                    
                    简单理解: 流程控制就是来控制我们的代码按照什么结构顺序来执行
                              流程控制主要有三种结构,分别是顺序结构,分支结构,循环结构,这三种结构代表三种代码执行的顺序

                              JS语言为我们提供了两种废止结构语句
                              1. if 语句
                              2. switch 语句

                              (1) if 的语法结构 如果=if 
                                  
                                   if (条件表达式) {
                                    //执行语句
                                   }
                                  if条件表达式的结果为真,就执行花括号里面的执行语句,
                                  如果这个条件表达式为假,则不执行花括号内的语句,而是执行if 语句后面的代码

                                  代码示例:
                                          if (3 > 5) {
                                            alert('沙漠骆驼')
                                          }
                                          因为这个表达式结果为假,所以的不执行alert
                                
                              案例:弹出一个输入框,要求用户输入年龄,如果年龄大于等于18岁,允许进入网吧.

                                        var bcd = prompt('请输入您的年龄');
                                        if (bcd >= 18) {
                                            alert('欢迎来到网吧');
                                        }else{
                                            alert('未成年不能进入网吧')
                                        }

                              (2) if else 双分支语句
                                 
                                  1.语法结构 if=如果 else=否则
                                    if (条件表达式) {
                                      //执行语句1
                                    }else{
                                      //执行语句2
                                    }
                                  2. 执行思路,如果表达式结果为真,那么执行语句1,否则执行语句2

                                  案例: 判断当前年份是否是闰年
                                   
                                    思路: 能被4整除且不能被100整除或者能被400整除的就是闰年

                                          这个案例会用到 取余=% , &&=并且 , ||=或者

                                         
                                          var year = prompt('请输入想要查询的 年份');

                                          if (year % 4 == 0 && year % 100 != 0 || year % 400 == 0) {
                                            //条件表达式解析:
                                            //              输入的变量值被4整除为0,并且不能被100整除,或者能够被400整除为0 的变量值就为闰年
                                               alert(year + '年是闰年');
                                          }else{
                                               alert(year + '年是平年');
                                          }
    
                                  案例: 判断是否中奖
                                        接收用户输入的姓名,来判断是否中奖,如果输入的是刘德华,则提示中了5块钱,否则提示没有中奖。

                                       var inputa = prompt('请输入您的姓名')

                                       if (inputa == '刘德华') {
                                        
                                           alert('恭喜您中奖五元');
                                       } else {
                                           alert('很遗憾您没有中奖');
                                       }
                                      
                                       或者可以这样写
                                       var name = ('刘德华')
                                       var inputa = prompt('请输入您的姓名')

                                       if (inputa === name) {
                                           alert('恭喜您中奖五元');
                                       } else {
                                           alert('很遗憾您没有中奖');
                                       }
                              
                    [3] 多分支语句 if else if
                        
                        多分支语句就是利用多个条件来选择不同的语句执行,得到不同的结果,也就是多选一的过程

                        语法规范:
                        if (条件表达式1) {
                            //语句1
                            } else if(条件表达式2) {
                            //语句2
                            } else if(条件表达式3) {
                            //语句3
                            } else {
                            //语句4
                            }
                            
        
                    [4] 三元表达式
                        
                        由三元运算符组成的式子我们成为三元表达式

                        语法结构:
                                条件表达式 ? 表达式1 : 表达式2
                                思路为: 如果条件表达式的结果为真 则 返回表 达式1 的数值 如果为假 则 返回 表达式2 的数值

                        代码体验:  
                                var num = 10;
                                var result = num > 5 ?  '是的' : '不是的';
                                console.log(result);
                        
                        案例: 数字补0
                            
                            用户输入数字,如果数字小于10,则在前面补0 比如01,03,06,如果数值大于10,则不需要补0

                            var num = prompt('请输入数值');
                            var time = num < 10 ?  '0' + num : num ;
                            console.log(time);
                        

                    [5] 分支流程控制 switch 语句
                        
                        switch语句也是多分支语句,它用于基于不同条件来执行不同的代码.当要针对变量设置一系列的特定值的选项时候,就可以使用switch.

                        switch语句也可以实现多选一

                        语法结构: switch=转换.开关 case=案例.选项 break=退出 default=没有满足条件时执行的语句
                            
                                switch(表达式) {
                                case value1:
                                    执行语句1;
                                    break;//退出switch执行语句
                                case value2:
                                    执行语句2;
                                    break;
                                    //...更多其他的条件
                                default:x
                                    执行最后的语句;
                                    //表达式中没有一个满足条件的时候执行
                                }
                                // 3.执行思路﹑利用我们的表达式的值和 case后面的选项值相匹配如果匹配上,
                                    就执行该ca里面的语句如果都没有匹配上,那么执行default里面的语句.

                                    switch注意事项:
                                    
                                    1.switch语句一般用于一些比较固定的值的选项
                                    2.我们开发里面表达式我们经常写成变量
                                    3.我们num 的值和 case里面的值相匹配的时候是全等―必须是值和数据类型一致才可以num === 1
                                    4. break 如果当前的case里面没有break 则不会退出switch 是继续执行下一个case

                        案例: 查询水果价格的案例
                                
                        var fruit = prompt('请输入您要查询的水果')

                        switch (fruit) {
                            case ('苹果'):
                                alert('苹果10元一斤');
                                break;

                            case ('香蕉'):
                                alert('香蕉10元一斤');
                                break;

                            case ('葡萄'):
                                alert('葡萄10元一斤');
                                break;

                            default:    
                                alert('没有这种水果的价格');
                                break;
                        }
                    {//switch语句和if else if 语句的区别}
                    1.一般情况下，它们两个语句可以相互替换
                    2.switch ..case语句通常处理case为比较确定值的情况,而if...else...语句更加灵活，常用于范围判断(大于、 等于某个范围) 
                              2.switch ..case语句通常处理case为比较确定值的情况,而if...else...语句更加灵活，常用于范围判断(大于、 等于某个范围) 
                    2.switch ..case语句通常处理case为比较确定值的情况,而if...else...语句更加灵活，常用于范围判断(大于、 等于某个范围) 
                    3.switch语句进行条件判断后直接执行到程序的条件语句,效率更高。而if..else语句有几种条件,就得判断多少次         
                              3.switch语句进行条件判断后直接执行到程序的条件语句,效率更高。而if..else语句有几种条件,就得判断多少次         
                    3.switch语句进行条件判断后直接执行到程序的条件语句,效率更高。而if..else语句有几种条件,就得判断多少次         
                    4.当分支比较少时,if...else语句的执行效率比switch语句高。
                    5.当分支比较多时,switch语句的执行效率比较高,而且结构更清晰。


                    [1] for循环
                    
                        在程序中,一组被重复的执行的语句被称为循环体,能否继续重复执行,取决于循环的中止条件, 由循环体及循环的终止条件组成的语句
                        被称为循环语句
                        
                        for循环的语法结构:
                                        for(初始化变量;条件表达式;操作表达式){
                                        循环体
                                        } 
                        1. 初始化变量 就是用var声明一个普通的变量,通常用于计数器的使用
                        2. 条件表达式 就是用来决定每一次循环是否继续执行 就是终止的条件
                        3. 操作表达式 是每次for循环最后执行的代码经常用于我们的计数器变量进行更新(递增或者是递减)
                        
                        for (var i = 1; i<=100; i++;) {
                        console.log('你好');                            
                                    console.log('你好');                            
                        console.log('你好');                            
                        }
                        
                        for循环可以重复执行不同的代码 因为我们有计数器变量 i 的存在 i每次循环值都会变化

                        比如我们想要输出一个人1到100岁

                        for (var i = 1; i<=100; i++){
                        console.log(这个人活了 '+ i +'岁);
                        }

                    //    或者可以这么写:

                        for (i = 1 ; i<=100; i++) {
                            if (i == 1) {
                                console.log('这个人出生了,他今年一岁了');
                            } else if (i == 100) {
                                console.log('这个人今年100岁了,他去世了');
                            } else {
                                console.log('这个人今年'+i+'了');
                            }

                        }

                        案例: 求 1 到 100 之间整数的累加和.
                            
                            首先循环100次,我们需要一个计数器i
                            我们还需要一个存储结果的变量 sum ,但是初始数值一定是0
                            核心算法为: 1 + 2 + 3 + 4..... ,等同于 sum = sum + i;

                            var sum = 0;
                            for(var i = 1; i<=100; i++){
                            sum = sum + i
                            }
                            console.log('所以一加到一百的整数累加和是'+sum+'');

                        案例: 求 1 到 100 之间整数的累加和的平均值.

                            这个案例中出来需要一个存储累加和的变量,其次还需要一个平均值的变量 average
                            
                            var sum = 0;
                            var average = 0;

                            for (var i = 1; i <= 100; i++) {
                            sum +=i
                            }
                            average = sum / 100
                            console.log(' 1 到 100 之间整数的累加和的平均值是'+average+'');

                        案例: 求 1 到 100 之间所有偶数的和还有奇数的和.

                            偶数的和:
                                    Var even = 0;

                                    for(var i =1; i <= 100; i++){
                                    if(i % 2 == 0){
                                        even = even + i
                                    }
                                    }
                                    console.log('偶数的和是'+even+'');//2550

                            奇数的和: 
                                    var odd = 0;
                                    for (var i = 1; i <= 100; i++) {
                                    if (i % 2 != 0) {
                                        odd = odd + i
                                    }                                           
                                                }                                           
                                    }                                           
                                    }
                                    console.log('奇数的和是'+odd+'');

                        案例: 求 1 到 100 之间 所有能被 3 整除的数字的和
                            
                            var num = 0;

                            for(var i = 1; i<=100; i++){
                            if (i % 3 != 0) {
                                num = num + 1
                            }
                            }
                            console.log(num);
                            

                        案例: 要求用户输入班级人数,然后弹出等同于班级人数的输入框之后
                            再依次输入每个学生的成绩,最后打印出改版机的总成绩以及平均成绩

                            var num = prompt('请输入班级总人数')
                            var sum = 0; //总成绩
                            var average = 0; //平均成绩

                            for (var i = 1; i <= num; i++) {
                                var scroe = prompt('请输入第'+i+'个学生的成绩')
                                sum = sum + parseFloat(scroe)//这里需要使用parseFloat转化成字符型
                            }
                            average = sum / num

                            alert('班级总成绩是' + sum )
                            alert('班级平均分是' + average)
                            


                    [2] 双重for循环
                        
                        概述: 很多情况下,单层for循环并不能满足我们的需求,比如我们要打印应该五行五列的图形
                            或者打印一个倒直角三角形等,此时就可以通过循环嵌套来实现; 
                                       或者打印一个倒直角三角形等,此时就可以通过循环嵌套来实现; 
                            或者打印一个倒直角三角形等,此时就可以通过循环嵌套来实现; 

                            循环嵌套是指在一个循环语句中再定义一个循环语句的语法结构,例如在for循环中,可以
                            再嵌套一个for循环,这样的for循环语句我们称之为双重for循环.
                            
                            
                        案例: 打印五行五列星星★

                            var num = '';

                            for (var i = 1; i <= 5; i++){//外层for循环负责打印五行
                            for(var j = 1; j <= 5; j++){//里层for循环负责每行打印五颗星星
                                num = num + '★';
                            }
                            num = num + '\n';//如果不加换行25颗星星则会在一行显示,加了\n之后,在每一行打印完成之后都会换行继续打印
                            }

                            console.log(num);


                            案例: 打印n行n列星星★

                                    要求用户输入行数和列数,之后在控制台打印出用户输入行数和列数的星星

                                    这个案例和上面的案例的做法无非就是更改了固定的行数以及星星让用户去输入
                                    所以增加两个让用户输入的自变量就行了
                                    var num = '';

                                    var sum = prompt('请输入要打印多少行星星')

                                    var cum = prompt('请输入一行要打印多少颗星星')

                                    for(var i = 1; i <= sum; i++){//外层for循环负责打印五行
                                    for (var j =1; j <= cum; j++){//里层for循环负责一行打印五个星星
                                        num = num + '★';
                                    }
                                    num = num + '\n';//如果不加换行则会一行打印25颗星星,加了\n之后每一行打印五颗星星之后则会换行打印
                                    }
                                    console.log(num);

                            案例: 打印倒三角形
                                
                                    var str = '';
                                    
                                    for(var i = 1; i <= 10; i++){-+
                                    for(var j = i; j <=10; j++){
                                        str = str + '★';
                                    }
                                    str = str + '\n';
                                    }
                                    console.log(str);

                                    (1) 第一轮会从外层for循环开始,外层for循环第一步从var i = 1 开始,然后到下一步 i<=10; 中检测i是否
                                    小于等于 10,如果<=10 就会打印出第一行;然后跳转到var j = i 此时的 i=1,然后继续到下一步检测
                                    j = i = 1 是否 <=10,如果 <= 10,那么就会打印出第一行中的的一颗星星,然后随着 j++ 的不断变化增加
                                    j = i = 1 也在从初始值 1 慢慢增加 等j的数值 = 10 的时候,这个时候的第一行已经打印了 10 颗星星
                                    紧接着 j 的数值继续增加,增加到 11 的时候,再继续和 j<=10 比较 然后发现 11 已经不 <= 10,然后跳转到
                                    外层for循环的循环体把换行指令打印出,自此外层for循环和里层for循环,第一轮结束.

                                (2)第二轮会从第一轮的换行指令结束后直接跳转到外层for循环的 i++ 之后 i的值会从 1 增加为 2 再继续和
                                i<=10进行比较,接下来的流程和第一轮一样.... 直到到了第二轮里层for循环之中的var j = i = 2 这里开始和
                                第一轮不一样,这也是打印倒直角三角形算法的精髓所在,因为 var j = i = 2 一直会通过 j++ 自增到 11 ,
                                这会比第一轮的 var j = i = 1 一直自增到 11 少循环一轮,那也就是说第二行的星星也会比第一行的星星
                                少打印一颗,所以第二行的星星只会有 9 颗, 再然后随着外层for循环 i 自增的数值越来越大,那么里层的for循环
                                也会从少打印一颗逐渐变成少打印两颗,三颗,四颗,直到结束,一个到倒立的直角三角形就会被打印出来.

                            案例: 打印正三角形

                                正三角形打印方法一:
                                
                                var str = '';

                                for(var i = 0; i <= 10; i++){
                                    for(var j = i - 1; j <= 10; j++){//核心算法是 j = i - 1
                                        str = str + '★'; 
                                                    str = str + '★'; 
                                        str = str + '★'; 
                                    }
                                    str = str + '\n';
                                }
                                console.log(str);

                                正三角形打印方法二:

                                var num = '';

                                for(var i = 1; i <= 9; i++){
                                    for (var j = 1; j <= i; j++){//核心算法是 j <= i
                                        num += '★';
                                    }
                                    num = num + '\n';
                                }
                                console.log(num);

                            案例: 打印九九乘法表
                                
                                var str = '';

                                for(var i = 1; i <= 9; i++){
                                for(var j = 1; j <= i; j++){
                                    str += j + 'x' + i + '=' + j * i + '\t';
                                }
                                str += '\n';
                                }
                                console.log(str);

                    [3] for循环小结
                        
                        1.for循环可以重复执行某一些相同的代码
                        2.for循环可以重复执行些许不同的代码,因为由计数器的存在
                        3.for循环可以重复执行某些操作,比如算术运算符加法操作
                        4.随着需求的增加,双重for循环可以做更多,更好看的效果
                        5.双重for循环,外层循环一次,内层for循环全部执行
                        6.for循环是循环条件和数字直接相关的循环
                        7.分析要比写代码更加重要
                        8.一些核心算法想不到,但是要学会,分析他的执行过程
                        9.会学举一反三,自己经常总结,做一些相似的案例


                    [4] while循环
                        
                        while循环语句可以在条件表达式为真的前提下, 循环执行指定的一段代码,知道条件表达式不为真时和结束循环

                        while循环的语法结构如下:
                                            while (条件表达式) {
                                            循环体代码
                                            }

                                            1. 执行思路: 当条件表达式结构为true 则执行循环体 否则 退出循环
                                            2. while循环里面也应该有初始化变量
                                            3. 里面也应该有操作表达式,完成计数器的更新 防止死循环 
                                                       3. 里面也应该有操作表达式,完成计数器的更新 防止死循环 
                                            3. 里面也应该有操作表达式,完成计数器的更新 防止死循环 

                            案例: 打印一个人的一生,从一岁到一百岁.

                                var i = 1;
                                
                                while (i <= 100) {
                                console.log('这个人今年'+ i +'岁了');
                                i++
                                }

                            案例: 计算 1 ~ 100 之间所有整数的累加和

                                var i = 1;
                                var j = 0;

                                while (i <= 100) {
                                j = j + i;
                                i++
                                }
                                console.log(j);

                            案例: 弹出一个输入框, 你爱我吗? 如果输入我爱你,就提示结束,否则,就会一直询问.
                                
                                var i = prompt('你爱我吗?')

                                while (i !== '我爱你' ||'爱' ||'爱你') {
                                var i = prompt('你爱我吗?')
                                }
                                alert('我也爱你')


                    [5] do while 循环 
                    
                        do...while 语句其实就是while语句的一个变体

                        语法结构: 
                                do {
                                //循环体代码 - 条件表达式为 true 时重复执行循环体的代码
                                } while (条件表达式);

                        执行思路: 
                                跟while循环不同的地方在于 do while 先执行一次循环体 再去判断条件 如果条件表达式的结果为true
                                则继续执行循环体,否则退出循环

                        代码验证: 
                        var i = 1;
                        do {
                        console.log('你好');
                        i++
                    } while (i <= 100);
                        
                        do...while的循环体至少执行一次.

                        
                            案例: 打印一个人的一生,从一岁到一百岁
                                
                                var i = 1;

                                do {
                                console.log('这个人今年'+ i +'岁了');
                                } while (i <= 100);

                            案例: 计算 1 ~ 100 之间所有整数的累加和
                                
                                var i = 1;
                                var j = 0;
                                do {
                                j = j + i;
                                i++
                                } while (i <= 100);
                                console.log(j);

                            案例: 弹出一个输入框, 你爱我吗? 如果输入我爱你,就提示结束,否则,就会一直询问.

                                do {
                                i = prompt('你爱我吗?')
                                } while (i !=='我爱你' || '爱你' || '爱');

                                alert('我也爱你');
                    
                                
                    [6] 循环小结
                    
                        1. JS中循环有 (for循环) (while循环) (do...while循环) 
                                 1. JS中循环有 (for循环) (while循环) (do...while循环) 
                        1. JS中循环有 (for循环) (while循环) (do...while循环) 
                        2. 三个循环很多情况下都可以相互代替使用
                        3. 如果是用来记录次数,和数字相关的,三者使用基本相同,但是for循环会更加常用一些
                        4. while 和 do...while循环 可以做更复杂的判断条件,会比for循环灵活一些
                        5. while 和 do...while循环的执行顺序不一样,while先判断后执行,do...while先执行一次,再去判断执行
                        6. while 和 do...while 执行次数不一样,do...while至少会执行一次循环体,而while可能一次也不会执行
                        7. 实际工作中会更加常用到for循环

                
                    [7] continue 关键字
                    
                        continue关键字用于立即跳出本次循环,继续下一次循环(跳出本次循环后代码就会少执行一次)

                        案例: 一共吃五个包子,跳过吃第三个包子
                        
                            for (var i = 1; i <= 5; i++) {
                            if (i == 3) {
                                continue;//只要遇见了continue就跳出本次循环,直接跳到i++
                            }
                            console.log('我正在吃第个'+ i +'包子')
                            }

                        案例: 求 1 ~ 100 之间,除了能被7整除之外的整数和

                            var sum = 0;
                            for (var i = 1; i <= 100; i++) {
                            if (i % 7 == 0) {
                                continue;
                            }
                            sum += i;
                            }
                            console.log(sum);

                        
                    [8] break 关键字
                    
                        break关键字用于立即跳出整个循环(循环结束)

                        案例: 吃五个包子,吃到第三个包子大仙里面有半个虫子,其余的不吃了

                            for (var i = 1; i <= 5; i++) {
                            if (i == 3) {
                                break;//遇到break 退出整个循环,所以一共吃了两个包子
                            }         
                            console.log('我吃到第'+ i +'个包子');                               
                                        console.log('我吃到第'+ i +'个包子');                               
                            console.log('我吃到第'+ i +'个包子');                               
                            }



                    [1] 数组
                    
                        数组的概念:

                        问: 之前学习的变量,只能存储一个值,如果我们想要存储一个班上所有学生的名字,那么该如何去储存?
                        答: 可以使用数组(Array) 数组可以把一组相关的数据一起储存,并提供方便的访问权限(获取)方式

                        问: 什么是数组?
                        答: 数组是指一组数据的集合,其中每个数据都被称作为元素,在数组中可以存放任意类型的元素,数组
                            是将一组数据存储在单个变量名下的优雅方式.

                            //普通变量一次只能存储一个值
                            var num = 10;
                            //数组一次可以存储多个值,并且可以存储任意的数据类型
                            var arr = [1,2,'pink',true]

                        JS中数组创建有两种的方式:
                        
                            1. 利用new创建数组
                            var 数组名 = new Array ();
                            var arr = new Aarry ();//创建了一个空的数组

                            2. 利用数组字面量来创建数组 
                                     2. 利用数组字面量来创建数组 
                            2. 利用数组字面量来创建数组 
                            var arr = [];//创建了一个空的数组

                            3. 数组中的数据一定要通过逗号来分割

                            4. 数组里面的数据被称为 '数组元素'

                            5. 数组的字面量是方括号[]

                            6. 声明数组并赋值称为 '数组的初始化'

                            7. 这种字面量方式也是以后 '使用最多的方式'


                    [2] 获取数组元素 
                             [2] 获取数组元素 
                    [2] 获取数组元素 

                    (1) 数组的索引
                        
                        索引(下标): 用来访问数组元素的序号 (数组下标从0开始)

                        var arr = ['小白','小黑','大黄','旺财'];
                            索引号:  0      1      2      3

                        数组可以通过索引来'访问',设置,修改对应的数组元素,我们可以通过 '数组名[索引]'的方式来获取数组中的元素

                        这里的'访问'就是获取到的意思


                        例如在以下数组中我们需要访问'大黄'这个数组元素

                            var arr1 = ['小白','小黑','大黄','旺财'];
                            console.log(arr1[2]);
                            这时候就可以获取到 '大黄'这个数组元素

                            如果arr1 获取的是 console.log(arr1[4]); 因为没有这个数组元素 所以会提示输出的结果是 undefined.


                        (2) 遍历数组

                            问题: 怎么把数组里面的元素全部提取出来?

                            '规律': 从代码中我们可以发现,从数组中抽取一个元素时,代码是重复的,有所不一样的是 '索引值在递增'

                            答案就是 '循环' 
                                     答案就是 '循环' 
                            答案就是 '循环' 

                            遍历数组就是把数组元素从头到尾都访问一遍

                            举例说明:
                                    var arr = ['red','green','blue'];
                                    
                                    for (var i = 0; i < 3; i++) {
                                    console.log(arr[i]);
                                    }
                                    1. 因为我们数组的索引号从 0 开始, 所以 i 必须从 0 开始 i < 3
                                    2. 输出的时候 arr[i] i计数器当索引号使用

                            
                            案例: 请将 “关羽”，“张飞”，“马超”，“赵云”，“黄忠”，“刘备”，"姜维”;数组里的元素依次打印到控制台.

                            var arr = ['关羽','张飞','马超','赵云','黄忠','刘备','姜维'];

                            for (var i = 0; i < 7; i++) {
                                console.log(arr[i]);
                            }

                            注意: 但是数组中的元素不可能每一次都去一个一个数,所以我们可以使用 '数组元素.length'

                                数组元素.length 可以动态监测数组元素的个数(数组长度)

                            如果用.length的方法来写以上的案例那就是

                            var arr = ['关羽','张飞','马超','赵云','黄忠','刘备','姜维'];

                            for (var i = 0; i < arr.length; i++) {
                                console.log(arr[i]);
                            }


                            案例: 求数组[2,6,1,7,4] 里面所有元素的和以及平均数
                            
                                1. 声明一个求和变量sum 以及一个平均值变量average
                                2. 遍历整个数组,把里面的每个数组元素都加到 sum 里面
                                3. 用求和变量 sum 除以数组的长度就可以得到这个数组的平均值

                                var arr = [2,6,1,7,4];
                                var sum = 0;
                                var average = 0;

                                for (var i = 0; index < arr.length; i++) {
                                sum = sum + arr[i]; //我们加的是数组元素中的每一个值 arr[i] 不是计数器 i
                                average = sum / arr.length;
                                }
                                console.log(sum,average);  // 想要输出多个变量,使用逗号分隔就可以了

                            案例: 求数组[2,6,1,77,52,25,7] 中的最大值.

                                1. 声明一个保存最大元素的变量 max
                                2. 默认最大值可以取数组中的第一个元素
                                3. 遍历这个数组,把里面每个数组的元素都和刚刚声明的max的默认变量相比较
                                4. 如果这个数组元素大于 max 就把这个数组元素存到max里面,否则就继续下一轮的比较.
                                5. 最后输出这个max

                                var arr = [2,6,1,77,52,25,7];
                                var max = arr[0];

                                for (var i = 1; i <arr.length; i++) {
                                if (arr[i] > max) {
                                    max = arr[i];
                                }
                                }
                                console.log('这个数组中的最大值是'+ max);

                        
                            案例: 将数组['red','green','blue','pink'] 转化为字符串,并且用|符号分割

                                1. 需要一个新的变量用于存放转换完的字符串 str
                                2. 遍历原来的数组, 分别把里面的数据取出来,加到字符串里面
                                3. 同时在后面多加一个分隔符号

                                var arr = ['green','blue','pink','red'];
                                var str = '';
                                var sep = '*';
                                for (var i = 0; i < arr.length; i++) {
                                str += arr[i] + sep;
                                }
                                console.log(str);


                        (2) 数组新增元素,修改length长度

                            var arr = ['red','green','blue'];
                            arr.length = 5;
                            现在我们手动把数组的长度修改成了5,这时候里面一个有五个元素
                            但是由于新增元素没有赋值,所以如果用log输出的话,结果就是 undefined


                        (3) 可以通过修改数组索引新增数组元素
                        
                            新增数组元素 可以通过 修改索引号 来追加数组元素

                            var arr1 = ['red','green','blue'];
                            arr[3] = 'pink';
                            这就会在数组第三个元素上追加一个 'pink'

                            arr[0] = 'hotpink';
                            如果数组中已经有了元素,在原来的数组元素上在追加一个数组元素,那就会替换掉原来的数组元素

                            arr1 = '有点意思';
                            不可以直接给数组名赋值,否则里面的数组元素全都会消失,只会留下一个 '有点意思'.


                        案例: 新建一个数组, 里面存放了10个整数(1 ~ 10).
                            
                            核心原理: 使用循环来追加数组
                            1. 声明一个空的数组 arr.
                            2. 循环中的计数器 i 可以作为数组元素存入.
                            3. 由于数组的索引号是从0开始的,因此计数器从 0 开始更合适,存入的数组元素要 +1.

                            var arr = [];
                            for (var i = 1; i < 10; i++) {
                            arr[i] = i + 1;
                            }
                            console.log(arr);

                        
                        案例: 将数组[2,0,6,1,77,0,52,0,25,7]中大于等于10的元素选出来,放入新数组.

                        
                        案例: 将数组[2,0,6,1,77,0,52,0,25,7]中大于等于10的元素选出来,放入新数组.

                            var arr = [2,0,6,1,77,0,52,0,25,7];

                            var arr1 = [];

                            var j = 0;

                            for (var i = 0; i < arr.length; i++) {
                            if (arr[i] >= 10) {
                                arr1[j] = arr[i];
                                j++;
                            }

                            }
                            console.log(arr1);

                            方法二:
                            var arr = [2,0,6,1,77,0,52,0,25,7];
                            var newarr = [];
                            //   刚开始newarr.length就是0

                            for (var i = 0; i < arr.length; i++) {
                                if (arr[i] >= 10;) {
                                newarr[newarr.length] = arr[i];
                                // 新数组索引号从0开始,依次递增
                            }
                            }
                            console.log(aewarr);

                            如果 arr 里面的 i 大于等于了10,就把这个元素存给 newarr.length,
                            刚开始的时候.length的长度是0 所以的一个把第一个77存给了.length,
                            '数组的长度可以自动检测里面元素的变化'所以等到下一轮52的时候
                            .length的长度已经变成了1,再把52的元素存给长度1,依次循环.


                            案例︰将数组[2,0,6,1,77,0,52,0,25,7]中的0去掉后,形成一个不包含0的新数组.

                            var arr = [2,0,6,1,77,0,52,0,25,7];
                            var newarr = [];

                            for (var i = 0; i < arr.length; i++) {
                                if (arr[i] != 0) {
                                newarr[newarr.length] = arr[i];
                            }
                            }
                            console.log(newarr);


                            案例: 反转数组
                            把['red', 'green', 'blue', 'pink', ' purple'];数组翻转


                            var arr = ['red', 'green', 'blue', 'pink', ' purple'];

                            var newarr = [];

                            for (var i = arr.length - 1; i >= 0; i--) {
                                newarr[newarr.length] = arr[i];

                            }
                            console.log(newarr);

                        


                    [1] 函数的概念

                        在 JS 里面，可能会定义非常多的相同代码或者功能相似的代码，这些代码可能需要大量重复使用。

                        虽然 for循环语句也能实现一些简单的重复操作,但是比较具有局限,此时我们就可以使用 'JS 中的函数'。

                        '函数'：就是封装了一段'可被重复调用执行的代码块'。通过此代码块可以实现大量代码的重复使用。


                    [2] 函数的使用
                    
                        函数的使用分为两步: '声明函数' 和 '调用函数'

                        1. 声明函数

                        语法规范:
                                function 函数名() {
                                    //函数体
                                }
                                例如:
                                        function sayhi() {
                                        console.log('sayhi');
                                        }
                        注意事项: 1. function 声明函数的关键字 全部小写
                                    2. 函数是做某件事情, 函数名一般都是动词 例如 sayhi
                                    3. 函数如果不调用,自己不会执行
                                    

                        2. 调用函数

                            调用的方法是函数名加上小括号
                            例如: sayhi();
                            //调用函数的时候千万不要忘记加小括号

                            '注意:声明函数本身并不会执行代码，只有调用函数时才会执行函数体代码。'


                        3. 函数的封装

                        函数的封装是把一个或者多个功能通过函数的方式封装起来，对外只提供一个简单的函数接口

                        简单理解：封装类似于将电脑配件整合组装到机箱中 '类似快递打包'

                        案例: 利用函数来求 1 ~ 100 的累加和
                            
                            function getsum(sum1,sum2) {
                            var sum = 0;
                            for (var i = sum1; i <= sum2; i++) {
                                sum += i;
                            }
                            console.log(sum);
                            }
                            getsum(1,100);

                        
                        4. 函数的参数
                        
                        函数的参数分为 '实参'和'形参'

                        在声明函数时，可以在函数名称后面的小括号中添加一些参数，这些参数被称为'形参'，而在调用该函数时，
                        同样也需要传递相应的参数，这些参数被称为'实参'。

                            1. 我们可以通过函数参数实现函数重复不用的代码
                            
                            function 函数名(形参1,形参2) {   "声明函数的小括号里面是形参(形式上的参数)

                            }
                            函数名(实参1,实参2) 在调用的小括号里面的是实参 (实际上的参数)

                            2. 形参和实参执行的过程

                            function cook(aru) {
                                console.log(aru);
                            }
                            cook('酸辣土豆丝');
                            cook('大肘子');

                            在执行的过程中并不会直接去执行 function 里面的代码 而是先略过
                            先去执行的是(函数调用),函数被调用之后再回头去找(函数声明) 在
                            调用的过程中发现实参里面有一个酸辣土豆丝,那么酸辣土豆丝就会把
                            这个实参传递给aru这个形参,从而得到实参是用来写(实际参数)的,而
                            (形参)是用来接受(实参)的

                            注意: 形参是用来接收实参的,相当于代码执行了 aru = '酸辣土豆丝'
                                    把酸辣土豆丝赋值给了aru ,形参类似一个变量.}


                        总结: 

                            形参: 形式上的参数 是函数在定义的时候传递的参数 当前并不知道是什么
                            实参: 实际上的参数 是函数在调用的时候传递的参数 实参是传递给形参的

                            参数的作用: 在'函数内部'的某些值不能固定,我们可以通过参数在'调用函数时传递'的时候来决定


                            案例: 利用函数求任意两个数的和
                            
                                function getsum(num1,num2) {
                                console.log(num1 + num2);
                                }
                                getsum(500,1200);

                            案例: 利用函数求任意两个数之间的和
                            
                                function getnum(start,end) {
                                var num = 0;
                                for (var i = start; i <= end; i++) {
                                    num += i
                                }
                                console.log(num);
                                }

                                getnum(1,100);

                                注意点:
                                        1. 多个参数之间用逗号隔开
                                        2. 形参可以看做是不用声明的变量


                            3. 函数的形参和实参个数不匹配的问题

                            function getsum(num1,num2) {
                                console.log(num1+num2);
                            }
                            
                            (1) 如果实参的个数和形参个数一致,则会正常输出结果
                                getsum(1,2);
                            (2) 如果实参的个数多于形参的个数,只会取到形参的个数
                                getsum(1,2,3);
                            (3) 如果实参的个数小于形参的个数 多余的形参会被定义为 (undefined)最终的数值是NaN
                                形参可以看作是不用声明的变量 num2 是一个变量但是没有接受值 结果就是 undefined.
                                getsum(1);

                                所以请我们一般情况下尽量让实参的个数和形参相匹配

                                js中如果形参不传值它默认的值是 undefined.

                                小结:
                                    1. 函数可以带参数也可以不带参数
                                    2. 声明函数的时候函数名括号里面的是形参,形参的默认值为 undefined
                                    3. 调用函数的时候,函数名括号里面的是实参
                                    4. 多个参数中间用逗号分隔
                                    5. 形参的个数可以和实参个数相匹配,但是结果不好预计,我们尽量要匹配.


                        [3] 函数的返回值
                        
                            1. return 语句
                            
                            有的时候,我们会希望函数将值返回给调用者,此时通过使用renturn语句就可以实现.

                            函数返回值的格式: 
                                            function 函数名() {
                                                return 需要返回的结果;
                                            }
                                            函数名();
                            (1) 我们函数只是实现某种功能,最终的结果需要返回给函数的调用者也就是 '函数名()'
                                是通过return来实现的
                            (2) 只要函数遇到return 就把后面的结果 返回给函数的调用者 :函数名() = return 后面的结果

                            案例: 求任意两个数的和
                                
                                function getSum(num1,num2) {
                                return num1 + num2;
                                }
                                console.log(getSum(1,2));

                            案例: 利用函数求任意两个数的最大值
                                
                                function getmax(num1,num2) {
                                if (num1 > num2) {
                                    return num1;
                                } else {
                                    return num2;
                                }
                                }
                                console.log(getmax(2,6));

                                由于他的判断条件比较少,我们可以使用三元表达式:

                                function getmax(num1,num2) {
                                return num1 > num2 ? num1 : num2;
                                }
                                console.log(getmax(55,99));

                            案例: 利用函数的方法求[5,2,99,101,67,77]这个数组中的最大数值

                                var arr = [5,2,99,101,67,77];

                                function getmax(arr) {
                                var max = arr[0];
                                for (var i = 1; i < arr.length; i++) {
                                    if (arr[i] > max) {
                                        max = arr[i];
                                    }
                                }
                                return max;
                                }

                                console.log('这个数组中的最大值是' + getmax(arr));
                                
                                或者也可以这么写:
                                
                            1. 在实际开发中 我们经常用一个变量来接受 函数的返回值 这样使用起来更简单.
                                var re = getmax([5,2,99,101,67,77]);
                            //    相当于 arr 接收了一个数组 arr = [5,2,99,101,67,77];
                                console.log(re);


                            2. return 终止函数

                            return语句之后的代码将不会被执行

                            函数返回值的注意事项:

                            (1) return 终止函数

                                function gatsum(num1,num2) {
                                    return num1 + num2;//return 后面的代码将不会被执行
                                    alert ('这段代码将不会被执行');

                                }
                                console.log(getsum(1, 2));

                            (2) return 只能返回一个值

                                function fn(num1,num2) {
                                    return num1, num2;
                                    //return返回的值一定是最后一个值,所以这段代码返回的是2
                                }
                                console.log(fn(1, 2));

                            (3) 求任意两个数加减乘除的结果

                                function  getresult(num1,num2) {
                                    return [num1 + num2, num1 - num2, num1 * num2, num1 / num2];
                                }
                                var re = getresult(6 , 3);
                                console.log(re);//返回的是一个数组.


                            (4) 函数没有 return 返回 undefined
                                
                                函数都是有返回值的

                                1. 如果 return 则返回 return 后面的值
                                2. 如果没有 return 则返回 undefined


                            (5) break,continue,return 之间的区别
                                
                                break: 结束当前循环(比如for还有while)
                                continue: 跳出本次循环,继续执行下次循环(比如for还有while)
                                return: 不仅可以退出循环,还能够返回return语句中的值,同时还可以结束当前函数体内的代码


                        [4] arguments的使用
                        
                            当我们不确定有多少个参数传递的时候,就可以使用arguments来获取,在JavaScript中,
                            arugments实际上他是一个当前函数的一个内置对象,所有的函数都内置了一个arugments对象
                            arguments对象中存储了传递过来的所有实参.

                            只有函数才有arguments对象,而且是每个函数都内置好了这个arguments.


                            例如:
                            function fn() {
                            console.log(arguments);//里面储存了所有传递过来的实参
                            console.log(arguments.length);//最终的调用有多或少个实参,他的长度就是多少个
                            console.log(arguments[2]);//获取某一个元素
                            当我们需要把传递过来的实参全部打印出来的时候
                            我们可以按照数组的方法遍历数组
                            for (var i = 0; i < arguments.length; i++) {
                                console.log(arhuments[i]);
                                // 这样就可以打印出所有传递过来的实参
                            }
                            }
                            fn(1, 2, 3);

                            arugments 展示形式是一个伪数组,并不是真正意义上的数组

                            1. 具有数组的 length 属性
                            2. 按照所应当方法进行存储
                            3. 不具有数组的 ,push() , pop() 等方法


                        案例: 用函数求任意个数的最大值

                            function getmax() {
                            var max = arguments[0];
                            for (var i = 1; i < arguments.length; i+) {
                                if (arguments[i] > max) {
                                    max = arguments[i]
                                    }

                                }
                            return max;
                            }
                        
                        console.log(getmax(6, 9, 45, 453453, 453, 45153));
                        console.log(getmax(55491, 14820, 535, 41533, 53151));


                        案例: 利用函数反转任意数组  reverse = 翻转

                            function reverse(arr) {
                            var newArr = [];
                            for (var i = arr.length - 1; i >= 0; i--) {
                                newArr[newArr.length] = arr[i];
                            }
                            return newArr;
                            }
                            var arr1 = reverse([1, 3, 5, 9, 8, 55]);
                            console.log(arr1);
                            var arr2 = revere (['red', 'pink', 'blue']);
                            console.log(arr2);


                        案例: 利用函数冒泡排序 sort = 排序

                            function sort(arr) {
                            for (var i = 0;i < arr.length - 1; i++) {
                                for (var j = 0; j < arr.length - i; i++){
                                    if (arr[j] > arr[j + 1]) {
                                        var temp = arr[j];
                                        arr[j] = arr[j + i];
                                        arr[j + 1] = temp;
                                    }
                                }
                            }
                            return arr;
                            }

                            var arr1 = sort ([1, 2, 3, 4, 5, 6, 7, 8, 9]);
                            console.log(arr1);


                        案例: 利用函数判断闰年
                        
                            function isrunyear(year) {
                            //如果是闰年就返回 true 否则就返回 false
                            var flag = false;
                            if (year % 4 =0 && year % 100 != 0 || year % 400 == 0) {
                                flag = true;
                            }
                            return flag;
                            }
                            console.log(isrunyear(2000));
                            console.log(isrunyear(1999));
                        
                            
                        [5] 函数可以条用另一个函数

                            因为每一个函数都是独立的代码块,用于完成特殊的任务,因此经常会用到函数互相调用的情况

                            函数时可以互相调用的:
                            
                            function fn1() {
                                console.log(11);
                                fn2();
                            }
                            fn1();
                            function fn2() {
                                console.log(22);
                            }

                            执行过程:  第一步走到 fn1 函数发现没有调用,走到了 fn(1) 然后打印了一个11,打印完成之后
                                        发现里面调用了一个 fn2() ,现在他再跳到fn2这个函数上 然后因为fn2函数俩面打印了
                                        一个22,所以先打印了一个11,再打印了一个22.

                            案例: 以下这段代码的执行顺序
                                
                                    function fn1() {
                                    console.log(111);
                                    fn2();
                                    console.log('fn1');
                                    }
                                    function fn2() {
                                    console.log(222);
                                    console.log('fn2');
                                    }
                                    fn1();

                                    这段代码开始执行,到的一个函数fn1的时候发现并没有被执行,紧接着走到了函数fn2,但是fn2
                                    也没有被执行,所以直接走到了 fn1(); 然后这里开始调用函数fn1里面的函数,先打印了一个 111,
                                    然后走到了 fn2(); 再去调用 fn2 里面的函数 然后打印了一个 222,然后log又打印了一个'fn2',
                                    fn2();调用完成之后再回到刚刚的函数fn1;再去按照顺序打印了一个'fn1',
                                    所以打印的顺序是 111 ,222 ,'fn2' ,'fn1'.


                                案例: 用户输入年份,输出当前年份2月份的天数.
                                    如果是闰年就输出2月份的天数是29天,如果是平年就输出2月份的天数是28天.

                                
                                    function  isrunyear(year) {
                                    var year = prompt();

                                    var flag = ('year' + '年是平年,所以2月份的天数是28天');

                                    if (year % 4 ==0 && year % 100 != 0 || year % 400 == 0) {
                                        flag = ('year' + '年是闰年所以2月份的天数是29天');
                                    }
                                    return flag;
                                    }
                                    document.write(isrunyear(year));

                        
                        [6] 函数的两种声明方式
                        
                            1. 利用函数关键字来自定义函数,也被称为 ['命名函数']
                            
                            function fn() {

                            }
                            fn();
                            这里的 ['fn'] 就是函数名.

                            2. 函数表达式,通过变量声明的方式来声明一个函数,也被称为['匿名函数']
                                
                            语法: var fun = function() {};

                            实例: var fun = function(aru) {
                                console.log(我是函数表达式);
                                console.log(我是匿名函数);
                                console.log(aru);
                            }
                            fun('pink老师');
                            
                            (1) 由于fun是一个变量名,并不是一个函数名, 所以他是一个 ['匿名函数'].                           
                                        (1) 由于fun是一个变量名,并不是一个函数名, 所以他是一个 ['匿名函数'].                           
                            (1) 由于fun是一个变量名,并不是一个函数名, 所以他是一个 ['匿名函数'].                           
                            (2) 函数的声明方式和便改良的声明方式差不多,只是变量存的是值,函数表达式里面存的是函数.
                            (3) 函数表达式也可以进行传递参数.
                                    
                
                        [7] JavaScript作用域

                            1. 通常来说,一段程序代码中所用到的名字(变量)并不总是有效和可用的,而['限定这个名字(变量)的可用性范围']
                            就是这个名字的['作用域'].

                            2. 作用域的使用提高了程序的逻辑性,增强了程序的可靠性,减少了名字的冲突.

                            3. js的作用域(ES6)之前: 全局作用域  和  局部作用域

                            4. (局部作用域)也被称为(函数作用域) 在函数内部就是局部作用域,这个代码的名字就是变量名
                            只在函数内部起效果和作用

                            案例: 
                                    function fn(params) {
                                    var num = 20;
                                    //这里就是局部作用域,这里的num只在这个函数内部起作用
                                    console.log(num);
                                    }
                                    fn();

                        
                        [8] 变量的作用域
                        
                            根据作用域的不同可以把变量分为,全局作用域以及局部作用域.

                            (1) 全局变量

                            1. 在全局作用域下的变量 - 在全局都可以使用,包括某些函数的内部也是可以调用的.

                                比如说:  
                                    var num = 10;//这里的num是一个全局变量

                                    function name() {
                                        console.log(num);
                                        //上面的num在这个函数的内部也是可以被调用的.
                                    }
                                    name();
                        
                            2. 注意: 如果说在函数内部 一个'没有通过声明的变量',而是'直接赋值的变量'也是'属于全局变量'.

                                比如说:
                                    function name() {
                                        num1 = 10;
                                        //这里的变量就是没有声明,而是直接赋值的变量,所以他是全局变量.

                                    }
                                    name();

                            
                            (2) 局部变量
                                
                                1. 局部变量就是局部作用域下的变量 或者在函数内部的变量 就是局部变量

                                比如说: 
                                        function name(aru) { //函数的形参也可以看作是一个局部变量
                                        var sum = 10;
                                        //这里的sum就是一个局部变量,只能在函数内部使用;

                                        }
                                        name();
                                        如果此时使用 console.log(); 来输出sum ,就会报错,因为
                                        这里的log属于在全局中调用了函数局部中的变量,所以会报错.


                            (3) 从执行效率来看全局和局部变量.
                                    
                                全局变量:
                                        在任何一个地方都可以使用,但是只有在浏览器关闭的时候才会被销毁,'因此会比较占内存'

                                局部变量:
                                        只有在函数内部才可以使用,当其代码块被执行的时候会被初始化,但是当代码块运行结束之后
                                        就会被销毁,'因此会更节省内存的空间'


                        [9] 作用域链
                        
                            1. 只要是代码就至少有一个作用域链

                            2. 但是如果函数中还有函数,那么在这个作用域中就又可以诞生一个作用域链
                            
                            3. 根据在内部函数可以访问外部函变量的这种机制,用 '链式查找' 决定哪些数据能被内部函数访问
                            就被称作'作用域链'

                            内部函数访问外部函数的变量,采取的是 '链式查找' 的方式来决定取哪个值,这种结构我们称作为
                            作用域链,'也可以理解为在CSS中的就近原则'

                            比如说:

                                    var num = 10;

                                    function name() {//这是外部函数
                                        var num = 20;

                                        function fun() {//这是内部函数
                                            console.log(num);
                                            
                                        }
                                        fun();
                                    }
                                    fn();
                                    如果在以上的代码中的内部函数中输出 num 的值那他就会采取就近原则,去输出外部函数的中
                                    声明的函数,而不是第一个声明的 num  所以最后输出的值是 20.

                                案例:
                                    var a = 1;

                                    function name() {
                                        var a = 2;
                                        var b = '22';

                                        name2();
                                        function name2() {
                                            var a = 3;

                                            name3();
                                            function name3() {
                                                var a = 4;

                                                console.log(a);//a的值是多少?

                                                console.log(b);//b的值是多少?
                                            }
                                        }
                                    }
                                    name1();
                                    在求a和b的值的时候可以使用一个非常实用并且简单的技巧,就是 '站在目标角度出发,谁离他最近,最后的值就是多少'      
                                                在求a和b的值的时候可以使用一个非常实用并且简单的技巧,就是 '站在目标角度出发,谁离他最近,最后的值就是多少'      
                                    在求a和b的值的时候可以使用一个非常实用并且简单的技巧,就是 '站在目标角度出发,谁离他最近,最后的值就是多少'      
                                    所以a和b的值最后分别是 4 和 22 .



                        [10] JavaScript 预解析
                        
                            JavaScript代码是由浏览器中的JavaScript解析器来执行的。
                            JavaScript解析器在运行JavaScript代码的时候分为两步:预解析和代码执行。

                        1. 我们js引擎运行js分为两步:预解析代码执行
                            (1).预解析js引擎会把js里面所有的 'var' 还有 'function'提升到当前作用域的最前面
                            (2).代码执行按照代码书写的顺序从上往下执行

                        2. 预解析分为变量预解析(变量提升)和函数预解析(函数提升)
                            (1).变量提升就是把所有的变量声明提升到当前的作用域最前面不提升赋值操作
                            (2).函数提升就是把所有的函数声明提升到当前作用域的最前面不调用函数

                            
                            案例1:

                            console.log(num);

                            var num = 10;
                            //上面这段代码log输出的值并不是10,而是undefined
                            //因为他首先会进行与解析的操作
                            //就相当于执行了以下代码:

                            var num;//首先把变量的声明提升到当前作用域的最前面,但是不会进行赋值操作
                            console.log(num);
                            num = 10;
                            //最后按照代码执行顺序执行,所以log最终的值是undefined


                            案例2:

                            fun();

                            var fun = function () {
                            console.log(22); 
                                        console.log(22); 
                            console.log(22); 
                            }
                            //以上的代码最后输出的结果会报错,而并不是会调用输出一个22
                            //它相当于执行了以下代码:
                            
                            var fun;//因为他是一个变量表达式,所以我们还是要把变量声明提升到当前作用域的最前面.
                            fun();
                            
                            fun = function () {
                            console.log(22);
                            }
                            //因为在声明了fun之后,第二行代码直接调用了fun函数,但是以后代码并没有fun函数,所以最终会报错


                            案例3: 结果是多少?
                        
                            var num = 10;
                            fun();

                            function fun() {
                            console.log(num);
                            var num = 20;
                            }
                            //它相当于执行了以下操作

                            var num;

                            function fun() {
                            var num;
                            console.log(num);
                            num = 20;
                            }
                            num = 10;
                            fun();

                            所以最终的值是 undefined 
                                       所以最终的值是 undefined 
                            所以最终的值是 undefined 


                            案例4: 结果是多少?
                        
                            var num = 10;

                            function fn() {
                            console.log(num);
                            var num = 20;
                            console.log(num);
                            }
                            fn();
                            //它相当于执行了以下操作

                            var num;

                            function fn() {
                            var num;
                            console.log(num);
                            num = 20;
                            console.log(num);
                            }
                            num = 10;
                            fn();

                            所以最终输出的值是 undefined 和 20


                            案例5: 结果是多少?

                            var a = 18;
                            f1();

                            function f1() {
                            var b = 9;
                            console.log(a);
                            console.log(b);
                            var a = '123';
                            }
                            //它相当于执行了以下代码:

                            var a;

                            function f1() {
                            var b;
                            b = 9;
                            var a;
                            console.log(a);
                            console.log(b);
                            a = '123';
                            }
                            a = 18;
                            fn();

                            所以最终输出的值是 undefined 和 9

                            
                            案例6: 结果是多少?

                            f1();
                            console.log(c);
                            console.log(b);
                            console.log(a);

                            function f1() {
                            var a = b = c = 9;
                            console.log(a);
                            console.log(b);
                            console.log(c);
                            }
                            //它相当于执行了以下代码:

                            //第一步: 首先把函数声明提升到当前作用域的最前面.
                            function f1() {
                            var a = 9;
                            b = 9;
                            c = 9;
                            // var a = b = c = 9;
                            //第二步: 这一步并不是集体声明 ,并不是执行了 var a = 9, b = 9, c = 9; 集体声明中间用逗号隔开.
                            //而是相当于执行了 var a = 9; b = 9; c = 9; 
                            //所以在这一步中只有 a 是声明的变量, b 和 c都并没有声明,而是直接赋值的变量
                            //因为在函数的作用域中我们学习到:函数内部 一个'没有通过声明的变量',而是'直接赋值的变量'也是'属于全局变量'.
                            //所以 b 和 c 都是全局变量

                            console.log(a);
                            console.log(b);
                            console.log(c);
                            }
                            //最后一步因为没有需要提升的函数或者变量,所以依次罗列就好
                            f1();
                            console.log(c);
                            console.log(b);
                            console.log(a);

                            所以最终输出的值分别是 9, 9, 9, 9, 9, 报错.


                        [11] 对象(object)

                            1. 什么是对象?

                            在JavaScript中,对象是一组无序的相关属性和方法的集合,所有的事物都是对象,例如字符串、数值、数组、函数等。

                            对象是由属性和方法组成的.

                            (1) 属性:事物的特征，在对象中用属性来表示(常用名词)
                            (1) 方法:事物的行为，在对象中用方法来表示(常用动词)

                            例如一部手机他可以看作是一个对象

                            他的属性有: 大小, 颜色, 重量, 屏幕尺寸, 厚度等等 都可以称为 {'属性'}
                            他的方法有: 打电话, 发短信, 玩游戏, 砸核桃等等 都可以称为 {'方法'}

                            1.2 为什么需要对象?

                                保存一个值时，可以使用变量，保存多个值(一组值)时，可以使用数组。如果要保存一个人的完整信息呢?

                                例如，将“张三疯”的个人的信息保存在数组中的方式为︰
                                var arr = [张三疯，'男',128,154]; //无法分辨有些数据代表什么.

                                而在JS中的对象表达结构更清晰,更强大.张三疯的个人信息在对象中的表达结构如下:

                                张三疯.姓名 = '菜虚鲲';      >>>>>>>>>     person. name = '菜虚鲲'; 
                                            张三疯.姓名 = '菜虚鲲';      >>>>>>>>>     person. name = '菜虚鲲'; 
                                张三疯.姓名 = '菜虚鲲';      >>>>>>>>>     person. name = '菜虚鲲'; 
                                张三疯.性别 = '男';          >>>>>>>>>     person. sex ='男';
                                张三疯.年龄 = 128;           >>>>>>>>>     person. age = 128;
                                张三疯.身高 = 154 ;          >>>>>>>>>     person . height = 154;

                        
                            2. 创建对象的三种方式
                            
                            在JavaScript中,现阶段我们可以采用三种方式创建对象( object ) :

                            (1) 利用字面量创建对象.
                            (2) 利用new Object创建对象.
                            (3) {利用构造函数来创建对象}

                            2.1 利用字面量创建对象
                                
                                对象字面量: 就是花括号{}里面包含了表达这个具体事物(对象)的属性和方法.
                                {}里面采取键值对的形式表示

                                键: 相当于属性名
                                值: 相当于属性值，可以是任意类型的值(数字类型、字符串类型、布尔类型，函数类型等)


                                示例:

                                var obj = {};//创建了一个空的对象.

                                var obj = {
                                uname: '菜虚鲲',
                                age: 18,
                                sex: '男'
                                sayHi: function () {
                                    console.log('hi~');
                                }
                                }

                                (1)里面的属性或者方法我们采取键值对的形式  键(属性名) : 值(属性值)
                                (2)多个属性或者方法中间用逗号隔开的
                                (3)
                                

                            2.2 使用对象

                            (1) 调用对象的属性: 我们采用  {对象.属性名}  这个.(点)我们可以理解为'的'.
                                console.log(obj.uname);

                            (2) 调用属性的另一种方法:  对象名['属性名']
                                console.log(obj['age']);

                            (3) 调用对象的'方法' sayHi    对象名.方法名();   千万不能忘记添加括号
                                obj.sayHi();


                            2.3 变量、属性、函数、方法的区别
                                
                            (1) 变量和属性的相同的他们都是用来存储数据的

                                变量: 单独声明并赋值使用的时候直接写变量名单独存在
                                属性: 在对象里面的不需要声明的使用的时候必须是   对象.属性

                            (2)函数和方法的相同点都是实现某种功能做某件事

                                函数: 是单独声明并且调用的函数名()单独存在的
                                方法: 是在对象里面调用的时候  对象.方法()


                            3. 利用 new Object 创建对象

                                var obj = new Object();//创建了一个空的对象
                                //追加属性和方法:
                                obj.uname = '张三丰';
                                obj.age = '18';
                                obj.sex = '男';
                                obj.sayHi = function () {
                                console.log('hi~');
                                }
                                (1) 我们是利用等号 = 赋值的方法添加对象的属性和方法
                                (2) 每个属性和方法之间用分号结束
                                (3) 使用对象的方法和字面量一样


                            4. 我们为什么需要构造函数
                            
                            (1) 就是因为我们前面两种创建对象的方式一次只能创建一个对象
                            
                            (2) 因为我们一次创建个对象， 里面很多的属性和方法是大量相同的我们只能复制

                            (3) 因此我们可以利用函数的方法重复这些相同的代码我们就把这个函数称为构造函数

                            (4) 又因为这个函数不一样，里面封装的不是普通代码，而是对象

                            (5) 构造函数就是把我们对象里面一些相同的属性和方法抽象出来封装到函数里面
                            
                        
                            4.1 利用构造函数创建对象

                                构造函数的语法:

                                function 构造函数名() {
                                    this.属性 = 值;
                                    this.方法 = function() {}
                                }
                                //构造函数的使用
                                new 构造函数();

                                案例: 现在我们需要通过构造函数来创建四大天王的信息

                                function Star(uname, age, sex) {
                                this.name = uname;
                                this.age = age;
                                this.sex = sex;
                                this.sing = function (sang) {
                                    console.log(sang);
                                }
                                }
                            var ldh = new Star('刘德华', 18, '男');//调用函数的时候返回的是一个对象
                            console.log(ldh.name);//使用的方法
                            console.log(ldh['sex']);//使用的方法
                            ldh.sing('冰雨');//方法
                            
                            //这样的话就可以创建多个对象

                            var zxy = new Star('张学友', 18, '男');
                            console.log(zxy.name);
                            console.log(zxy['sex']);

                            (1) 构造函数名字首字母要大写
                            (2) 我们构造函数不需要return 就可以返回结果
                            (3) 我们调用构造函数 必须使用 new
                            (4) 我们只要 new Star() 调用函数就创建一个对象 ldh {}
                            (5) 我们的属性和方法前面必须添加this

                            4.3 构造函数和对象
                            
                            (1) 构造函数明星泛指的某一大类它类似于java语言里面的类(class)
                            (2) 对象特指是一个具体的事物刘德华 == {name:"刘德华", age: 18,sex:"男" , sing: f}
                            (3) 我们利用构造函数创建对象的过程我们也称为对象的实例化


                            4.4 new 关键字执行过程

                                (1) 在内存中创建一个新的空对象
                                (2) 让 this 指向这个新的代码
                                (3) 执行构造函数里面的代码,给这个新的对象添加属性和方法.
                                (4) 返回这个新对象 (所以构造函数里面不需要return) 
                                         (4) 返回这个新对象 (所以构造函数里面不需要return) 
                                (4) 返回这个新对象 (所以构造函数里面不需要return) 

                            
                            4.5 遍历对象的属性
                            
                                可以使用 for...in 语句用于对数组或者对象的属性进行循环操作

                                遍历对象案例:
                                    
                                    var obj = {
                                    name: 'pink老师',
                                    age: 18,
                                    sex: '男'
                                    }
                                    //这个时候我们就可以使用 for...in

                                    for (var k in obj) {//声明一个 K 变量,但是不要赋值
                                    console.log(k);//输出变量 K ,得到的是属性名
                                    console.log(obj[k]);//如果输出的是 obj[K] 得到的就是属性值
                                    }
                                    我们使用 for in 里面的变量 一般情况下 我们都会喜欢写 K 或者是 Key

                            5 对象小结
                            
                                (1) 对象可以让代码的结构更清晰
                                (2) 对象属于复杂数据类型
                                (3) 本质: 对象就是一组无序的相关属性和方法的集合
                                (4) 构造函数泛指某一大类,比如苹果 不管是红苹果还是绿色苹果,都被统称为苹果
                                (5) 对象实例特指某一事物,比如这个苹果,正在给你上课的老师
                                (6) fon...in 语句用于对数组或者对象的属性进行循环操作

                        
                        [12] 内置对象
                        
                            (1) JavaScript 中的对象分为三种: 自定义对象, 内置对象, 浏览器对象.
                            (2) 前面两种对象是JS基础内容,属于ECMAScript; 第三个浏览器对象属于我们JS独有的,后续在 JS API 会有讲解
                            (3) 内置对象就是JS语言自带的一些对象,这些对象供开发者使用,并提供了一些常用的或者是最基本而必要的功能(属性和方法)
                            (4) 内置对象最大的优点就是帮助我们快速开发
                            (5) JavaScript 提供了多个内置对象: Math, Date, Array, String等

                        1. 查文档
                        
                            学习一个内置对象的使用,只要学会其常用成员的使用即呵,我们可以通过查文档学习,可以通过MDN/W3C来查询.

                            Mozilla开发者网络(MDN )提供了有关开放网络技术(Open Web )的信息,包括HTML、CSS和万维网及HTML5应用的API.

                            MDN网址: https://developer.mozilla.org/zh-CN/

                        2. 如何学习对象中的方法
                        
                            (1) 查阅该方法的功能
                            (2) 查看里面参数的意义和类型
                            (3) 查看返回值的意义和类型
                            (4) 通过demo 进行测试

                        
                        3. Math 最大值的使用方法.

                        Math是数学对象,不是一个构造函数,所以我们不需要new 来调用,而是直接使用里面的属性和方法即可

                        例如:
                            console.log(Math.PI);//这是一个属性,可以输出圆周率
                            console.log(Math.max(5, 88, 1, 45));//这样可以直接输出最大值88,就可以不用循环来操作
                            console.log(Math.max(7, 66, 'pink老师'));//如果有不是数字类型的,就会显示NaN
                            console.log(Math.max());//如果里面不写入值,就会输出 -Infinity 
                                        console.log(Math.max());//如果里面不写入值,就会输出 -Infinity 
                            console.log(Math.max());//如果里面不写入值,就会输出 -Infinity 


                        4. math概述
                        
                        Math对象不是构造函数,它具有数学常数和函数的属性和方法.跟数学相关的运算(求绝对值，取整、最大值等)
                        可以使用Math中的成员。
                            
                        (1) 绝对值方法
                        
                            console.log(Math.abs(1));//输出的是1
                            console.log(Math.abs(-1));//输出的还是1,因为-1的绝对值还是1
                            console.log(Math.abs('-1'));//输出的也是1,这里会有一个隐式转换,会把字符串的 -1 转换成数字型
                            console.log(Math.abs('pink'));//NaN

                        (2) 三个取整方法
                            
                            1. Math.floor()   floor是地板的意思.  向下取整  往最小了取值  
                                      1. Math.floor()   floor是地板的意思.  向下取整  往最小了取值  
                            1. Math.floor()   floor是地板的意思.  向下取整  往最小了取值  

                            console.log(Math.floor(1.1));//输出的值是1,因为是向下取整
                            console.log(Math.floor(1.9)); //输出的也是1,因为是向下取整,不是向上

                            2. Math.ceil()  ceil是天花板的意思   向上取整   往最大了取值
                            
                            console.log(Math.ceil(1.1));//输出的是2,因为是向上取整
                            console.log(Math.ceil(1.9));//输出的是2,因为还是向上取整

                            3. Math.round()  四舍五入  其他数字都是四舍五入，但是 .5特殊  它会往大了取
                            
                            console.log(Math.round(1.1));//输出的是1
                            console.log(Math.round(1.5));//输出的是2
                            console.log(Math.round(1.9));//输出的是2
                            console.log(Math.round( -1.1));//输出的是 -1
                            console.log(Math.round( -1.5));// 这个输出的不是-2 而是-1 因为(五入)它会向大了取值 所以是 -1


                        5. Math对象随机数方法

                        (1) Math.random()  返回的是一个随机的小数  它大于等于0 小于1
                            这个方法里面不跟参数
                            console.log(Math.random());

                        (2) 我们想要得到两个数之间的随机整数并且包含这2个整数
                            Math.floor(Math.random() *(max - min + 1)) + min;


                            function getRandom(min, max) {
                                return Math.floor(Math.random() * (max - min + 1)) + min;
                            }
                            console.log(getRandom(1, 10));
                            //这样每次就可以随机到一个整数,同时包括 1 和 10

                        (3) 随机点名

                            var arr =[ '张三','张三丰','张三疯子','李四','李思思','pink老师'];

                            console.log(arr[getRandom(e,arr.length - 1)]);

                            
                    案例: 程序随机生成一个1~10之间的数字,并让用户输入一个数字

                        1. 如果大于该数字,就提示,数字大了,继续猜;
                        2. 如果小于该数字,就提示数字小了,继续猜;
                        3. 如果等于该数字,就提示猜对了,结束程序.

                    案例分析:
                        随机生成一个 1~10 的整数我们需要用到 Math.random() 方法. 
                                    随机生成一个 1~10 的整数我们需要用到 Math.random() 方法. 
                        随机生成一个 1~10 的整数我们需要用到 Math.random() 方法. 
                        需要一直猜到正确为止,所以一直循环.
                        用while循环合适更简单.
                        核心算法:使用if else if多分支语句来判断大于、小于、等于.


                        function getRandom(min, max) {
                                return Math.floor(Math.random() * (max - min + 1)) + min;
                            }

                            let random = getRandom(1, 10)

                            while (true) {//这里是一个死循环,最后需要一个终止条件
                                let num = ('请猜一个1到10之间的数字');
                                if (num > random) {
                                    alert('该数字大了');
                                } else if(num < random) {
                                    alert('该数字小了');
                                } else if(num = random) {
                                    alert('恭喜你猜对了');
                                    break;
                                }
                            }


                    案例: 程序随机生成一个1~10之间的数字,并让用户输入一个数字,但是只有10次机会
                    
                            function getRandom(min, max) {
                                return Math.floor(Math.random() * (max - min + 1)) + min;
                            }

                            let random = getRandom(1, 100);

                            let i = 1;
                            while (i++ <= 10) {
                                let chushi = prompt('猜一个1到100之间的数');
                                if (chushi < random) {
                                    alert('数字小了哦');
                                } else if (chushi > random) {
                                    alert('数字大了哦');
                                } else if (random = chushi) {
                                    alert('恭喜你猜对了');
                                    break;
                                }
                                if (i == 11) {
                                    alert('次数已经用光');
                                }
                            }

                        
                                                                
                        [13] 日期对象
                        
                            1. Date 概述
                            
                            (1) Date对象和Math对象不一样,他是一个构造函数,所以我们需要实例化后才能使用

                            (2) Date实例用来处理日期和时间


                            2. Date()方法的使用
                            
                            (1) 获取当前时间必须实例化

                            var now = new Date ();
                            console.log (now);


                            3. Date()构造函数的参数

                            如果括号里面有时间,就返回参数里面的时间.例旧期格式字符串为'2019-5-1',
                            可以写成new Date('2019-5-1')或者new Date(2019/5/1)


                            4. Date() 日期对象  是一个构造函数   必须使用  new  来调用创建我们的日期对象

                            var arr = new Array(); //创建一个数组对象
                            var obj = new object(); //创建了一个对象实例


                            5. 使用Date  如果没有参数返回当前系统的当前时间
                            
                            var date = new Date();//创建了一个实例对象,就算是完成了对象的实例化
                            console.log(date);


                            6. 参数常用的写法

                                数字型: 2019, 10, 01

                                字符串型: '2019-10-1 8:8:8'
                                
                                var date1 = new Date(2019, 10, 1); 
                                console.log(date1); //这里返回的是11月 , 并不是10月, 后续会说明

                                var date2 = new Date('2019-10-1 8:8:8');//字符串类更加常用
                                console.log(date2);


                            7. 日期的格式化
                            
                            我们想要2 019-8-8 8:8:8 格式的日期，要怎么办?

                            需要获取日期指定的部分，所以我们要手动的得到这种格式.

                                方法名                 说明                     代码
                            getFullYear()            获取当年              dObj.getFullYear()
                            getMonth()             获取当月(0-11)          dObj.getMonth()
                            getDate()              获取当天日期            dobj.getDate()
                            getDay()           获取星期几(周日0到周六6)    dObj.getDay()
                            getHours()             获取当前小时            dObj.getHours()
                            getMinutes()           获取当前分钟            dobj.getMinutes()
                            getSeconds()           获取当前秒钟            dobj.getSeconds()

                            
                            案例: 格式化日期年月日

                                var date = new Date();//首先实例化

                                console.log(date.getFullYear());//返回当前日期的年   2022

                                console.log(date.getMonth() + 1);//月份返回的月份小1个月   记得月份 +1 呦

                                onsole.log(date.getDate());//返回的是几号

                                console.log(date.getDay());// 周一返回的是1  周六返回的是6  但是周日返回的是0


                            案例: 我们写一个2022年10月18日星期二(按当前时间的案例)

                                var date = new Date();//首先实例化

                                var year = date.getFullYear();
                                var month = date.getMonth() + 1;
                                var dates = date.getDate();
                                var arr = ['星期日','星期一','星期二','星期三','星期四','星期五','星期六'];
                                var day = date.getDay();
                                console.log('今天是:' + year +'年'+ month + '月'+ dates + '日' + arr[day]);

                                
                            案例: 要求封装一个函数返回当前的时分秒格式 08:08:08

                                    function getTime() {
                                    var time = new Date();//首先实例化
                                    var h = time. getHours();
                                    h = h < 10 ? '0' + h : h;
                                    //因为在输出的时如果不加这段代码的话,会显得不美观
                                    //这段代码的意思就是:
                                    //当前的 h 小于10吗 如果小于10, 那就先写一个0 然后再加上h, 如果h大于0 那就只输出h
                                    //下面的变量 m 和 s 同理
                                    var m = time . getMinutes(); 
                                    m = m < 10 ? '0' + m : m;
                                    var s = time . getSeconds();
                                    s = s < 10 ? '0' + s : s;
                                    return h + ':' + m + ':' + s;
                                    }
                                    console.log(getTime());


                    [14] 获得Date 总的毫秒数(时间戳)

                        总的毫秒数不是当前时间的毫秒数而是距离1970年1月1号过了多少毫秒数

                        1. 第一种方式是通过 valueOf() 和 getTime()
                        
                        var date = new Date ();
                        console. log(date.valueOf()); //就是我们现在时间距离 1970.1.1 总的毫秒数
                        console. log(date . getTime());
                    
                        2. 简单的写法(最常用的写法)

                        var date1 = +new Date(); // +new Date() 返回的就是总的毫秒数
                        console.log(date1);

                        3. H5 新增的获取方法

                        console . log(Date.now());//可以直接获取总督毫秒数
                        

                    案例: 倒计时

                        1. 核心算法: 输入的时间减去现在的时间,就是剩余的时间,也就是倒计时,但是不可以拿着
                            时分秒相减,可能会导致结果为负数
                        2. 用时间戳来做,用户输入时间的总的秒数减去现在时间的总的毫秒数,就可以得到剩余时间的总的毫秒数
                        3. 把剩余时间总的毫秒数转换为天, 时, 分, 秒 (时间戳转换为时分秒)

                        4. 转换的公式如下:

                            d = parseInt(总秒数 / 60 / 60 / 24); //计算天数
                            h = parseInt(总秒数 / 60 / 60 % 24); //计算小时
                            m = parseInt(总秒数 / 60 % 60 ); //计算分数
                            s = parseInt(总秒数 % 60); //计算当前秒数

                            function conutDown(time) {
                                var nowTime = +new Date(); //返回的是当前时间的总毫秒数
                                var inputTime = +new Date(time); //返回的是用户输入时间的总毫秒数
                                var times = (inputTime - nowTime) / 1000; //time是剩余时间的总秒数,
                                d = parseInt(times / 60 / 60 / 24); //计算天数
                                d = d < 10 ?  '0' + d : d;
                                h = parseInt(times / 60 / 60 % 24); //计算小时
                                h = h < 10 ?  '0' + h : h;
                                m = parseInt(times / 60 % 60); //计算分数
                                m = m < 10 ?  '0' + m : m;
                                s = parseInt(times % 60); //计算当前秒数
                                s = s < 10 ?  '0' + s : s;

                                return d + '天' + h + '时' + m + '分' + s + '秒';
                            }
                            document.write(conutDown('2022-10-19 11:07:00'));


                    
                    [15] 创建数组的两种方式

                        1. 利用数组字面量来创建数组
                        
                        var arr = [1, 2, 3];
                        console.log(arr[0]);


                        2. 利用new Array() 来创建数组

                        var arr1 = new Array(); //创建了一个空的数组
                        var arr1 = new Array(2);// 这样写的意思就是 数组的长度为2  里面有两个空的数组元素
                        var arr1 = new Array(2, 3, 5); //这杨等价于字面量的 [2, 3, 5] 这样写表示 里面有三个数组元素


                    [16] 检测是否为数组的两种方式
                    
                        1. instanceof 是一个运算符 它可以来检测是否为数组

                            var arr = [];//这是一个数组
                            var obj = {};//这是一个对象
                            console.log(arr intanceof Array);//返回的结果为true ,所以确实是数组
                            console.log(obj intanceof Array);//返回的是 false ,所以他不是一个数组

                        2. Array.isArray(参数);  
                            
                            这是H5新增的方法 ie9以上版本支持
                            console.log(Array.isArray(arr));//返回的结果为ture
                            console.log(Array.isArray(obj));//返回的结果为false


                    [17] 添加数组元素

                        1. push 在我们数组的末尾 添加一个或者多个数组元素   push也有 '推'的意思
                        
                        2. push() 参数可以直接写

                            var arr = [1, 2, 3];
                            arr.push(4, 'pink');//这就在上面arr数组的最后面追加了两个数组元素
                            console.log(arr.push(4, 'pink'));//push完毕之后,返回的是新数组的长度,原数组它也会发生变化


                        3. unshift在我们数组的开头添加一个或者多个数组元素

                        4. unshift() 参数可以直接写
                        
                            arr.unshift(4, 'pink');//这就在上面arr数组的最后面追加了两个数组元素
                            console.log(arr.unshift( 'red' , "purple ' ));
                            //unshift完毕之后,返回的是新数组的长度,原数组它也会发生变化


                    [18] 删除数组元素
                    
                        1. pop()它可以删除数组的最后一个元素

                        2. 原数组也会发生变化

                        var arr1 = [1, 3, 5];
                        arr1.pop(); //pop是可以删除数组的最后一个元素记住一次只能删除一个元素
                        console.log(arr.pop());//pop完毕之后,返回的结果是删除的那个元素


                        3. unshift()它可以删除数组的最后一个元素

                        4. 原数组也会发生变化
                        
                        var arr1 = [1, 3, 5];
                        arr1.unshift(); //unshift是可以删除数组的最前面一个元素记住一次只能删除一个元素
                        console.log(arr.unshift());//unshift完毕之后,返回的结果是删除的那个元素

                            
                        案例: 筛选数组,有一个包含工资的数组[1500,1200,2000,2100,1800],要求把数组中工资超过20oo的删除,剩余的放到新数组里面

                        var arr =[1500,1200,2000,2100,1800];

                        var newArr = [];

                        for (var i = o; i < arr.length; i++) {
                        if (arr[i] < 2000) {
                        // newArr[newArr.length] = arr[i];
                        newArr.push(arr[i]);//可以使用push的方法在新的数组里面追加新的数组元素
                        }
                    }
                        console.log(newArr);


                    [19] 数组排序

                        1. 反转数组

                        var arr = ['pink', 'red', 'blue'];
                        arr.reverse();//这是一个方法,可以直接把数组的元素进行翻转排序.
                        console.log(arr);

                        2. 数组排序(冒泡排序)

                        var arr1 = [13, 4, 77, 1, 7];

                        arr1.sort(function(a, b) {
                            return a - b ;//升序的顺序排列
                            return b - a ;// 降序的顺序排列
                        });
                        console.log(arr1);


                    [20] 获取数组元素索引

                        1. indexof(数组元素) 
                                
                            (1) 作用就是返回该数组元素的索引号从前面开始查找
                            (2) 它只返回第一个满足条件的索引号
                            (3) 它如果在该数组里面找不到元素，则返回的是-1

                            var arr = ['red', 'green' , 'blue', 'pink', 'blue'];
                            console.log(arr.indexOf('blue'));
                            //返回的是2

                        2. lastIndexOf(数组元素)

                            (1) 返回该数组元素的索引号从后面开始查找
                            (2) 它只返回第一个满足条件的索引号
                            (3) 它如果在该数组里面找不到元素，则返回的是-1

                            var arr = ['red', 'green' , 'blue', 'pink', 'blue'];
                            console.log(arr.indexOf('blue'));
                            //返回的是4


                    案例: 数组去重

                        要求: ['c', 'a', 'z', 'a', 'x', 'a', 'x', 'c', 'b'] 要求去除数组中重复的元素.
                        1. 目标:把旧数组里面不重复的元素选取出来放到新数组中，重复的元素只保留一个，放到新数组中去重.
                        2. 核心算法:我们遍历旧数组，然后拿着旧数组元素去查询新数组，如果该元素在新数组里面没有出现过，我们就添加，否则不添加.
                        3. 我们怎么知道该元素没有存在?利用新数组.indexOf(数组元素)如果返回时 -1 就说明新数组里面没有改元素
                                
                        封装一个去重的函数unique独一无二的

                            function unique(arr) {
                                var newArr = [];
                                for (var i = 0; i < arr.length; i++) {
                                    if (newArr.indexOf(arr[i]) == -1) {
                                        newArr.push(arr[i]);
                                    }
                                }
                                return newArr
                            }

                            var arr = unique(['c', 'a', 'z', 'a', 'x', 'a', 'x', 'c', 'b']);

                            // 这里function（arr）    就等于 function （arr = ['c','a'……………………）

                            console.log(arr);


                    [21] 数组转化字符串
                    
                        1. toString()
                            
                            将我们的数组转化为字符串

                            var arr = [1, 2, 3];
                            console.log(arr.toString());
                            //输出的结果为 1, 2, 3

                        2. join(分隔符)

                            1. 它可以在转化后的元素中添加你想要的分隔符号

                            var arr1 = ['pink', 'blue', 'green'];
                            console.log(arr1.join());
                            //如果不加分隔符号的话默认就是逗号

                            console.log(arr1.join('-'));
                            //这样的话输出的就是  pink-blue-green


                    [22] 基本包装类型

                        1. 为了方便操作数据类型, JavaScript 还提供了三个特殊引用类型: String Number Boolean

                        2. 基本包装类型就是把简单数据类型包装成为复杂数据类型, 这样基本数据类型就有了方法和属性

                        //下面的代码有什么问题吗?
                        
                        var str = 'andy';
                        console.log(str.length);

                        按道理来说基本数据类型是没有属性和方法的,只有对象才有属性和方法,但是上面的代码却可以执行,
                        这是因为Js会把基本数据类型包装为复杂数据类型,其执行过程如下:

                        1. 第一步生成一个临时变量, 把简单数据类型包装为复杂数据类型
                            var temp = new String('andy');

                        2. 赋值给我们声明的字符变量
                            str = temp;

                        3. 销毁临时变量
                            temp = null;


                    [23] 字符串不可变

                        例如:
                            var str = 'andy';
                            //这个是时候 str 的值就是 'andy'
                            //如果这个时候我们对str重新赋值 例如:
                            str = 'red';

                            1. 当我们在给这个 str 重新赋值的时候, 常量'andy' 是不会被修改或者消失的,他依旧存在于内存中
                            2. 而重新给字符串赋值的话,会在内存中新开辟一个空间, 这个特点就是字符串并不可变
                            3. 只是以前 str 指向的地址是 'andy' 再次赋值,只是改变了变量的指向地址
                            4. 由于字符串的不可变,在大量拼接字符串的时候会出现有效率的问题

                            例如:
                                var str = '';
                                
                                for (var i = 0; i < 10000000; i++) {
                                str += i;

                                }
                                console.log(str);
                                //这样的话字符串就会被无数遍的拼接
                                //结果需要大量的时间来显示, 因为它需要不断地开辟新的空间

                            
                    [24] 根据字符返回位置
                    
                        字符串所有的方法,都不会修改字符串本身(字符串是不可变的) ,操作完成会返回一一个新的字符串.

                        1. 变量名.indexOf('要查找的字符', 起始的位置)
                            
                            indexOf是从最开始的位置查找

                            let str = '我是练习时长两年半的,练习生菜虚鲲';

                            console.log(str.indexOf('练'));
                            //返回的结果是2
                            console.log(str.indexOf('练', 3));
                            //这个意思就是从第三个数组元素开始查找,返回的结果是8

                        2. 变量名.lastIndexOf('要查找的字符', 起始的位置)

                            与 indexOf 同理, 只是它是从数组的最后一位开始查找


                        案例: 查找字 符串"abcoefoxyozzopp"中 所有o出现的位置以及次数

                            1. 核心算法: 先查找第一个o出现的位置
                            2. 然后只要indexOf 返回的结果不是 -1 就继续往后查找
                            3. 因为indexOf 只能查找到第一个, 所以后面的查找, 一定是当前索引加1, 从而继续查找


                            var str = 'abcoefoxyozzopp';
                            var index = str.indexOf('o');
                            var num = 0;

                            while (index !== -1) {
                                console.log(index);
                                document.write(index);
                                num++;
                                index = str.indexOf('o', index + 1);
                            }
                            document.write('这个字符串出现了:' + num + '次');


                    [25] 根据位置返回字符(重点中的重点)
                    
                        1. charAt(index) 根据位置返回字符

                            var str = 'andy';
                            console .log(str.charAt(3));
                            //输出的是y

                            1.1 遍历所有字符

                                for (let i = 0; i < str.length; i++) {
                                console.log(str.charAt(i));
                                }

                        2. charCodeAt(index) 返回相应索引号的字符ASCII值   目的: 判断用户按下了那个键位

                            console.log(atr.charCodeAt(o));
                            //因为在ASCII表中 a 键位的值是97 所以最后输出的值为97

                        3. str[index]   H5新增的

                            console.log(str[0]);
                            //第0位是a 所以返回的是 a


                    案例: 判断一个字符串 'abcoefoxyozzopp' 中出现次数最多的字符，并统计其次数.

                            1. 核心算法: 利用 charAt()  遍历这个字符串
                            2. 然后把每个字符都存给一个新的变量, 如果遍历到这个属性的时候没有这个属性的时候
                                就把这个属性的值为1 , 如果遍历的时候此属性已经存在,那就再次 +1
                            3. 遍历对象, 得到最大值和该字符

                        var str = 'abcoefoxyozzopp';
                        //首先声明这个字符串

                        var o = {};
                        //因为我们需要把遍历出来的属性全部存到一个行新的对象里面,所以我们声明了一个对象 obj

                        for (var i = 0; i < str.length; i++) {
                        // console.log(str.charAt(i)); 
                        //到这一步为止,如果不进行其他的操作就已经把所有 str 里面的属性给遍历了出来
                        var chars = str.charAt(i);
                        if (o[chars]) {
                            // o[chars],就是o对象里str.charAT(i)属性的值

                            //如果有 O 里面str.charAt(i)的值那就给他的值赋1,代表它第一次出现
                            o[chars]++;
                        } else {
                            o[chars] = 1;
                        }

                        }
                        console.log(o);

                        // 接下来就可以使用遍历对象的方法来比较每个属性的值,从而获得最大值
                        var max = 0;
                        var ch = '';
                        for (var k in o) {
                        if (o[k] > max) {
                            max = o[k];
                            ch = k;
                        }
                        }
                        console.log('出现次数最多的字符是' + ch + '一共出现了' + max + '次');



                    [27] 字符串的操作方法(重点)
                    
                        1. concat('字符串1','字符串2')
                            
                            var str = 'andy';
                            console.log(str.concat('red'));
                            //输出的值为 andyred

                        2. substr('截取的起始位置','截取几个字符');

                            var str1 ='改革春风吹满地';
                            console.log(str1.substr(2,3));
                            //这个意思就是从索引 2 的位置开始取 3 个字符


                        课外查看:

                        1.   slice(start, end)  从start位置开始,截取到end位置, end取不到(他们俩都是索引号)

                        2.   substring(start, end)  从start位置开始,截取到end位置,end取不到基本和slice 相同但是不接受负值


                    [28] 替换字符串以及转换为数组
                    
                        1. 替换字符replace('被替换的字符','替换为的字符') 它只会替换字符串中第一个字符

                        var str = 'andyandy';
                        console .log(str .replace('a', 'b' ));
                        //输出的结果为  dndyandy

                        案例: 有一个字符串 'abcoefoxyozzopp' 要求把里面所有的0替换为*

                            var str1 = 'abcoefoxyozzopp' ;

                            while (str1.indexOf('o') !== -1) {
                            str1 = str1.replace('o', '*');
                            }
                            console.log(str1);
                            //输出的结果为  abc*ef*xy*zz*pp

                    
                        2. 字符转换为数组splif('分隔符')   前面我们学过join 把数组转换为字符串

                            var str2 = 'red, pink, blue';
                            console .log(str2.split(','));
                            //输出的就是 ["red", "pink", "blue"];

                            var str3 = ' red&pink&blue';
                            console.log(str3.split('&'));
                            //输出的就是 ["red", "pink", "blue"];

                            
                    [29] 简单类型与复杂类型
                        
                        简单类型又叫做基本数据类型或者值类型,复杂类型又叫做引用类型.

                        1. 值类型: 简单数据类型 & 基本数据类型,在存储时变量中存储的是值本身,因此叫做值类型

                        string , number , boolean , undefined , null

                        1.1 简单数据类型null 

                            var timer = null;
                            console . log(typeof timer);
                            //返回的是一个空的对象 object
                            如果有个变量我们以后打算存储为对象,暂时没想好放啥,这个时候就给null

                        
                        2. 引用类型: 复杂数据类型, 在储存的时候变量中存储的仅仅是地址(引用),因此也叫引用数据类型
                        
                            通过 new 关键字创建的对象 (系统对象, 自定义对象), 例如Object, Array, Date等等


                        3. 堆和栈

                            堆栈空间分配区别:

                            (1) 栈(操作系统) :由操作系统自动分配释放存放函数的参数值、局部变量的值等.其操作方式类似于数据结构中的栈;
                                //简单数据类型存放到栈里面

                            (2) 堆(操作系统) :存储复杂类型(对象) ,一般由程序员分配释放,若程序员不释放,由垃圾回收机制回收.
                                //复杂数据类型存放到堆里面

                        注意:JavaScript中没有堆栈的概念,通过堆栈的方式,可以让大家更容易理解代码的一些执行方式,便于将来学习其他语言.


                        4. 简单类型的内存分配

                            (1) 值类型(简单数据类型) : string , number , boolean , undefined , null
                            (2) 值类型变量的数据直接存放在变量 (栈空间)中
                            // 简单数据类型是存放在栈里面里面直接开辟个空间存 放的是值


                        5. 复杂类型的内存分配

                            (1) 引用类型(复杂数据类型) :通过new关键字创建的对象(系统对象、自定义对象) ,如Object. Array、 Date等
                            (2) 引用类型变量(栈空间)里存放的是地址,真正的对象实例存放在堆空间中
                            //复杂数据类型首先在栈里面存放地址十六进制表示 然后这个地址指向堆里面的数据


                    [30] 简单类型传参
                        
                            函数的形参也可以看作是一个变量,当我们把一个值类型变量作为参数传给了函数做形参时,其实就是把在栈空间里面的
                            的值复制了一份给形参,那么在方法内部对形参做任何修改,都不会影响到外部的变量

                            例如:
                                function fn(a) {
                                a++;
                                console.log(a);
                                }
                                var x = 10;
                                fn(x);
                                console.log(x);

                                //输出a的值最终是11, 但是对内部形参做的修改, 不会影响 x的值,它还会是 10


                    [31] 复杂类型传参

                            函数的形参也可以看做是一个变量 ,当我们把引用类型变量传给形参时,其实是把变量在栈空间里保存的堆地址复制给了形参,
                            形参和实参其实保存的是同一个堆地址,所以操作的是同一个对象.

                            function Person(name ) {
                                this.name = name ;
                            }
                            function f1(x) { //x = p
                                console.log(x.name); // 2.这个输出什么? 刘德华
                                x.name = "张学友";
                                console.log(x.name); // 3.这个输出什么? 张学友
                            }
                            Person("刘德华");
                            console.log(p.name); // 1.这个输出什么? 刘德华
                            f1(p);
                            console.log(p.name); // 4.这个输出什么? 张学友


                            

                           --------以上都为 JavaScript 基础阶段--------

                    


                    [1] JS基础阶段以及 Web APls阶段

                        1. JS基础阶段                                                2. Web APls阶段

                          (1) 我们学习的是ECMAScript标准规定的基本语法                  (1) Web APIs 是W3C组织的标准
                          (2) 要求同学们掌握Js基础的语法                                (2) Web APIs 我们主要学习 DOM 和 BOM
                          (3) 只学习基础语法,做不了常用的网页交互效果                   (3) web APIs是我们Js 所独有的部分
                          (4) 目的是为了Js后面的课程打基础,做铺垫                       (4) 需要使用Js基础的课程内容做基础


                          Js基础学习ECMAscript 基础语法为后面作铺垫,web APIs是Js的应用,大量使用us基础语法做交互效果


                    [2] DOM 简介
                      
                        1. 什么是 DOM

                           文档对象模型(Document Object Model,简称DOM),是W3C组织推荐的处理可扩展标记语言(HTML或者XML)的标准编程接口.

                           W3C已经定义了一系列的DOM接口,通过这些DOM接口可以改变网页的内容、结构和样式.


                        2. DOM树

                           ● 文档:一个页面就是一个文档, DOM中使用document表示

                           ● 元素:页面中的所有标签都是元素, DOM中使用element表示

                           ● 节点:网页中的所有内容都是节点(标签、属性、文本、注释等) , DOM中使用node表示

                        
                    [3] 获取数组元素

                        1. 如何获取页面的元素

                          ● DOM在我们实际开发中主要用来操作元素

                          ● 我们如何来获取页面中的元素呢 ?

                          ● 获取页面中的元素可以使用以下几种方式:
                            
                            (1) 根据 ID 获取
                            (2) 根据标签名获取
                            (3) 通过HTML5新增的方法来获取
                            (4) 特殊元素来获取


                        2. 根据ID获取

                           使用 getEementById() 方法可以获取带有ID的元素对象

                           Document的方法 getElementById() 返回一个匹配特定ID的元素.由于元素的ID在大部分情况下要求是独一无二的,
                           这个方法自然而然地成为了一个高效查找特定元素的方法.

                           id是大小写敏感的字符串,代表了所要查找的元素的唯一ID.

                           案例:
                               <body>
                                <div id = "time"> 2022-10-25</div>
                                <script>
                                    //1. 因为我们文档页面从上往下加载, 所以先得有标签, 所以我们script写到标签的下面
                                    //2. get是获取的意思   element是元素的意思  by是通过的意思  严格采用驼峰命名法
                                    //3. 参数 id 是大小写敏感的字符串
                                    //4. 返回的是一个元素对象
                                    var timr = document.getEementById('time');
                                    console.log(timer);
                                    //输出的是 2022-10-25
                                    console.log(typeof timer);
                                    //5. console.dir 打印我们返回的元素对象 跟好的查看里面的属性和元素
                                    </script>
                                </body>


                        3. 根据标签名来获取
                           
                           3.1 使用 getElementsByTagName() 方法可以返回带有指定标签的对象合集

                               语法: document.getElementsByTagName('标签名');

                               注意∶
                                    (1) 因为得到的是一个对象的集合,所以我们想要操作里面的元素就需要遍历.
                                    (2) 得到元素对象是动态的,也就是标签内容修改,js不需要修改也会同步.

                           3.2 还可以获取某个元素(父元素)内部所有指定标签名的子元素.

                               语法: element.getElementsByTagName ('标签名');//第一个element就是父元素的意思

                               注意:父元素必须是单个对象(必须指明是哪一个元素对象).获取的时候不包括父元素自己.


                           案例: 
                               <body>
                                    <ul>
                                        <li>知否知否,应是等你好久11</li>
                                        <li>知否知否,应是等你好久22</li>
                                        <li>知否知否,应是等你好久33</li>
                                        <li>知否知否,应是等你好久44</li>
                                        <li>知否知否,应是等你好久55</li>
                                    </ul>

                                    <ol>
                                        <li>生僻字1</li>
                                        <li>生僻字2</li>
                                        <li>生僻字3</li>
                                    </ol>

                                    <ol id="sum">
                                        <dl>蔡徐坤0</dl>
                                    </ol>
                                    <script>
                                        // 1.返回的是获取过来元素对象的集合,以伪数组的形式存储的
                                        var lis = document.getElementsByTagName('li');

                                        console.log(lis);//可以获取到5个小li

                                        console.log(lis[0]);//只打印出第一个小li的元素

                                        for (let index = 0; index < lis.length; index++) {
                                            console.log(lis[index]);
                                        }
                                        // 3．如果页面中只有一个li返回的还是伪数组的形式
                                        // 4．如果页面中没有这个元素返回的空的伪数组的形式

                                        // 5.如果我现在想要获取ol里面的子元素,就应该这么写:
                                        var num = document.getElementsByTagName('ol');
                                        // 哪怕没有这个ol元素返回的空的伪数组, 而伪数组是不能够作为父元素使用的
                                        // 那如果写成这样 : console.log(num.getElementsByTagName('li')); 那是肯定会报错的
                                        // 我们可以使用 以下方式来获取:
                                        console.log(num[0].getElementsByTagName('li'));
                                        //这个 num[0] 的意思等同于 ol[0] ,就是说 获取页面中第一个ol标签元素
                                        //如果还有一个 ol 那就可以写成 ol[1] 来获取 第二个 ol 下面的子元素 

                                        //或者以上的方法太过复杂,我们可以直接给 ol 一个 id (用第二个ol举例)

                                        var red = document.getElementById('sum'); //首先获取这个 sum , 也就是第二个ol 的 id名
                                        console.log(red.getElementsByTagName('dl'));
                                        //这样就可以把第二个 ol下面的子元素 dl 用id的方式获取                                        

                                    </script>
                                </body>


                        4. 通过HTML5新增的方法获取

                           (1) document.getElementsByClassName('类名'); //根据类名返回元素对象集合

                           (2) document.querySelector('选择器'); //根据指定选择器返回第一个元素对象

                           (3) document . querySelectorAll('选择器'); // 根据指定选择器返回所有的元素

                           案例:
                                <body>
                                    <div class="box">盒子1</div>
                                    <div class="box">盒子2</div>
                                    <div class="nav">
                                        <ul>
                                            <li>首页</li>
                                            <li>产品</li>
                                        </ul>
                                    </div>
                                    <srcipt>
                                       // 1. getElementsByClassName 根据类名获得某些元素集合
                                       var boxs = document.getElementsByClassName('box');
                                       console.log(boxs);
                                       //就可以打印出这两个元素对象

                                       // 2. querySelector 返回指定选择器的第个元素对象  
                                       //切记里面的选择器需要加符号  类选择器要加点(.)  id选择器要加井号(#)
                                       var firstBox = document.querySelector('.box');
                                       console.log(firstBox);
                                       var nav = document.querySelector('#nav');
                                       console.log(nav);
                                       var lia = document.querySelector('li'); 
                                       console.log(lia);
                                       //他只能返回第一个元素对象

                                       // 3. querySelectorAll()返回指定选择器的所有元素对象集合
                                       var allBox = document.querySelectorAll(' .box' );
                                       console.log(allBox);
                                       var lis = document.querySelectorAll('li');
                                       console.log(lis);
                                    </script>    
                                </body>
                     

                        5. 获取特殊元素( body , html )

                           (1) 获取body元素

                               语法:  doucumnet.body // 返回body元素对象
                                
                               var bodyEle = document.body;
                               console.log(bodyEle);

                           (2) 获取html元素

                               语法:  document.documentElement // 返回html元素对象

                               var htmlEle = document.documentElement;
                               console .log(htmlEle);


                    [4] 事件基础

                        1. 事件概述

                           ● JavaScript使我们有能力创建动态页面,而事件是可以被JavaScript侦测到的行为.

                           ● 简单理解: 触发---响应机制.
                           
                           ● 网页中的每个元素都可以产生某些可以触发JavaScript的事件,例如,我们可以在用户点击某按钮时产生一个
                             事件,然后去执行某些操作.

                             案例:

                                 <body>
                                    <button id="btn">唐伯虎</button>
                                    <script>
                                        //要求: 点击一个按钮，弹出对话框
                                        //  1. 事件是有三部分组成  <事件源>---<事件类型>---<事件处理程序>  我们也称为事件三要素
                                        // (1) 事件源   也就是事件被触发的对象
                                        var btn = document.getElementById('btn');
                                        // (2）事件类型如何触发, 是什么事件触发, 比如鼠标点击(onclick) 还是鼠标经过, 还是键盘按下
                                        // (3) 事件处理程序是通过一个函数赋值的方式来完成
                                        btn.onclick = function() {
                                            alert('点秋香');
                                        }
                                    </script>
                                 </body>


                        2. 执行事件的步骤

                          (1) 获取事件源
                          
                          (2) 注册事件(绑定事件)

                          (3) 添加事件处理程序(采取函数赋值形式)


                        3. 常见的鼠标事件
                            
                            鼠标事件               触发条件
                            
                            onclick             鼠标点击左键触发
                            onmouseover         鼠标经过触发

                            onmouseout          鼠标离开触发
                            onfocus             获得鼠标焦点触发

                            onblur              失去鼠标焦点触发
                            onmousemove         鼠标移动触发

                            onmouseup           鼠标弹起触发
                            onmousedown         鼠标按下触发


                        4. 操作元素
                         
                           JavaScript的DOM操作可以改变网页内容、结构和样式, 我们可以利用DOM操作元素来改变元素里面的内容、属性等

                           注意以下都是属性

                           4.1 改变元素内容

                               (1) 语法: elementl.innerText 

                               从起始位置到终止位置的内容,但它去除html标签,同时空格和换行也会去掉

                               (2) 语法: element.innerHTML

                               起始位置到终止位置的全部内容,包括html标签,同时保留空格和换行


                             案例需求: 当我们点击了按钮之后就会显示当前系统时间

                             <body>
                                <button>显示当前系统时间</button>
                                <div>某个时间</div>
                                <p>123</p>
                                <script>
                                    //当我们点击了按钮， div里面的文字会发生变化
                                    // 1．获取元素
                                    var btn = document.querySelector('button');
                                    var div = document.querySelector('div');
                                    //2.注册事件
                                    btn.onclick = function() {
                                        div.innerText = getDate();
                                    }

                                    function getDate() {
                                        var date = new Date();
                                        var year = date.getFullYear();
                                        var month = date.getMonth() + 1;
                                        var dates = date.getDate();
                                        var arr =[ '星期日','星期一','星期二','星期三','星期四','星期五','星期六'];
                                        var day = date.getDay();
                                        return '今天是:' + year + '年' + month + '月' + dates + '日' + arr[day];
                                    }
                                    //我们元素也可以不用添加事件,这样可以直接显示修改后的样式
                                    var p = document.querySelector('p');
                                    p.innerText = getDate();
                                </script>
                             </body>


                        5. innerText 和 innerHTML 的区别

                           案例: 
                                <body>
                                        <div></div>
                                        <p>
                                            我是文字
                                            <span>123</span>
                                        </p>
                                        <script>
                                            // 1. innerText 是不识别html标签   非标准   不显示去除空格和换行
                                            var div = document.querySelector('div');
                                            // div.innerText = '<strong>今天是：</strong> 2019';

                                            // 2. innerHTML 是识别html标签   是W3C标准  可以保留空格和换行的
                                            div.innerHTML = '<strong>今天是：</strong> 2019';
                                            // 这两个属性是可读写的  可以获取元素里面的内容
                                            var p = document.querySelector('p');
                                            console.log(p.innerText);
                                            console.log(p.innerHTML);
                                        </script>
                                    </body>

                        
                        6. 修改元素属性  src

                                <body>
                                <button id="ldh">刘德华</button>
                                <button id="zxy">张学友</button> <br>
                                <img src="images/ldh.jpg" alt="" title="刘德华">

                                <script>
                                    // 1. 获取元素
                                    var ldh = document.getElementById('ldh');
                                    var zxy = document.getElementById('zxy');
                                    var img = document.querySelector('img');
                                    // 2. 注册事件  处理程序
                                    zxy.onclick = function() {
                                        img.src = "images/zxy.jpg";
                                        img.title = '张学友思密达';
                                    }
                                    ldh.onclick = function() {
                                        img.src = "images/ldh.jpg";
                                        img.title = '刘德华';
                                    }
                                </script>
                                </body>

                            案例: 分时显示不同图片,显示不同问候语

                                  根据不同时间, 页面显示不同图片, 同时显示不同的问候语.
                                  如果上午时间打开页面, 显示上午好, 显示上午的图片.
                                  如果下午时间打开页面, 显示下午好, 显示下午的图片.
                                  如果晚上时间打开页面, 显示晚上好, 显示晚上的图片.

                                    <body>
                                    <img src="images/s.gif" alt="">
                                    <div>上午好</div>
                                    <script>
                                        // 根据系统不同时间来判断, 所以需要用到日期内置对象
                                        // 利用多分支语句来设置不同的图片
                                        // 需要一个图片, 并且根据时间修改图片, 就需要用到操作元素src属性
                                        // 需要一个div元素, 显示不同问候语, 修改元素内容即可
                                        // 1.获取元素
                                        var img = document.querySelector('img');
                                        var div = document.querySelector('div');
                                        // 2. 得到当前的小时数
                                        var date = new Date();
                                        var h = date.getHours();
                                        // 3. 判断小时数改变图片和文字信息
                                        if (h < 12) {
                                            img.src = "images/s.gif";
                                            div.innerHTML = '亲，上午好，好好写代码';
                                        } else if (h < 18) {
                                            img.src = "images/x.gif";
                                            div.innerHTML = '亲，下午好，好好写代码';
                                        } else {
                                            img.src = "images/w.gif";
                                            div.innerHTML = '亲，晚上好，好好写代码';
                                        }
                                    </script>
                                </body>
                           

                         7. 表单元素的属性操作

                            利用DOM可以操作如下表单元素的属性:

                            type、 value、 checked、 selected、disabled

                            案例:

                                <body>
                                    <button>按钮</button>
                                    <input type="text" value="输入内容">
                                    <script>
                                        //1.获取元素
                                        var btn = document.querySelector('button');
                                        var input = document.querySelector('input');
                                        // 2．注册事件处理程序
                                        btn.onclick = function() {
                                            // input.innerHTML ='点击了'; 它可以修改普通盒子比如,div标签里面的内容, 但是表单元素特殊,不是这样
                                            // 表单里面的 (值, 文字, 内容) 是通过value来修改的
                                            input.value ='被点击了';
                                            // 如果想要某个表单被禁用不能再点击  那就可以使用 disabled 我们想要button禁用 就可以这样写
                                            btn.disabled = true;
                                            // 或者也可以这样写:
                                            this.disabled = true;
                                            // this指向的是事件函数的调用者   当前函数的调用者是 buttton
                                        }
                                    </script>
                                </body>


                                案例: 仿京东显示密码

                                    点击按钮将密码框切换为文本框,并可以查看密码明文.

                                    案例分析:

                                      (1)核心思路: 点击眼睛按钮，把密码框类型改为文本框就可以看见里面的密码

                                      (2)一个按钮两个状态，点击一次，切换为文本框，继续点击一次切换为密码框

                                      (3)算法: 利用一个flag变量, 来判断flag的值, 如果是1就切换为文本框, flag设置为0, 
                                         如果是0就切换为密码框flag设置为1

                                            <head>
                                            <style>
                                            .box {
                                                position: relative;
                                                width: 300px;
                                                border-bottom: 1px solid rgba(100, 100, 100, 0.398);
                                                margin: 100px auto;
                                            }
                                            .box input{
                                                width: 370px;
                                                height: 30px;
                                                border: 0px;
                                            }
                                            .box label img {
                                                position: absolute;
                                                top: 10px;
                                                right: 10p
                                                width: 24px;
                                            }
                                            </style>
                                        </head>
                                        <body>
                                        
                                        <div class="box">
                                            <label for=""><img src="./jsapis_material/第一天/images/close.png" alt="" id="eye"></label>
                                            <input type="password" name id="pwd">
                                        </div>

                                        <script>
                                            //获取元素
                                            var eye = document.getElementById('eye');
                                            var pwd = document.getElementById('pwd');

                                            //注册事件
                                            var flag = 0;
                                            eye.onclick = function() {
                                            if (flag == 0) {                                                //点击了之后flag一定要发生变化
                                                pwd.type = 'text';
                                                eye.src = "./jsapis_material/第一天/images/open.png";
                                                flag = 1;
                                            } else {
                                                pwd.type = 'password';
                                                eye.src = "./jsapis_material/第一天/images/close.png";
                                                flag = 0;
                                            }                                      
                                            // eye.src = "./jsapis_material/第一天/images/open.png";
                                            }
                                        </script>
                                        </body>

                                         
                         8. 样式属性操作

                            我们可以通过JS修改元素的大小、颜色、位置等样式.

                            1. element.style      行内样式操作

                            2. element.className  类名样式操作

                            注意:
                               
                            (1) Js里面的样式采取驼峰命名法比如 fontSize、backgroundColor

                            (2) Js修改style样式操作, 产生的是行内样式, css权重比较高

                             
                            案例: 仿淘宝关闭二维码

                            核心思路:

                            1. 利用样式的显示和隐藏完成,display.none隐藏元素display:block显示元素
                            2. 点击按钮,就让这个二维码盒子隐藏起来即可

                                    <head>
                                    <meta charset="UTF-8">
                                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                                    <meta http-equiv="X-UA-Compatible" content="ie=edge">
                                    <title>Document</title>
                                    <style>
                                        .box {
                                            position: relative;
                                            width: 74px;
                                            height: 88px;
                                            border: 1px solid #ccc;
                                            margin: 100px auto;
                                            font-size: 12px;
                                            text-align: center;
                                            color: #f40;
                                            /* display: block; */
                                        }
                                        
                                        .box img {
                                            width: 60px;
                                            margin-top: 5px;
                                        }
                                        
                                        .close-btn {
                                            position: absolute;
                                            top: -1px;
                                            left: -16px;
                                            width: 14px;
                                            height: 14px;
                                            border: 1px solid #ccc;
                                            line-height: 14px;
                                            font-family: Arial, Helvetica, sans-serif;
                                            cursor: pointer;
                                        }
                                    </style>
                                </head>

                                <body>
                                    <div class="box">
                                        淘宝二维码
                                        <img src="images/tao.png" alt="">
                                        <i class="close-btn">×</i>
                                    </div>
                                    <script>
                                        // 1. 获取元素 
                                        var btn = document.querySelector('.close-btn');
                                        var box = document.querySelector('.box');
                                        // 2.注册事件 程序处理
                                        btn.onclick = function() {
                                            box.style.display = 'none';
                                        }
                                    </script>
                                </body>


                             案例:  循环精灵图背景

                                 可以利用for循环设置一组元素的精灵图背景

                                 案例分析:

                                 1. 首先精灵图图片排列有规律的

                                 2. 利用for循环修改精灵图片的背景位置background-position

                                 3. 让循环里面的i索引号*44就是每个图片的y坐标

                                    <head>
                                    <meta charset="UTF-8">
                                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                                    <meta http-equiv="X-UA-Compatible" content="ie=edge">
                                    <title>Document</title>
                                    <style>
                                        * {
                                            margin: 0;
                                            padding: 0;
                                        }
                                        
                                        li {
                                            list-style-type: none;
                                        }
                                        
                                        .box {
                                            width: 250px;
                                            margin: 100px auto;
                                        }
                                        
                                        .box li {
                                            float: left;
                                            width: 24px;
                                            height: 24px;
                                            background-color: pink;
                                            margin: 15px;
                                            background: url(images/sprite.png) no-repeat;
                                        }
                                    </style>
                                </head>

                                <body>
                                    <div class="box">
                                        <ul>
                                            <li></li>
                                            <li></li>
                                            <li></li>
                                            <li></li>
                                            <li></li>
                                            <li></li>
                                            <li></li>
                                            <li></li>
                                            <li></li>
                                            <li></li>
                                            <li></li>
                                            <li></li>
                                        </ul>
                                    </div>
                                    <script>
                                        // 1. 获取元素 所有的小li 
                                        var lis = document.querySelectorAll('li');
                                        for (var i = 0; i < lis.length; i++) {
                                            // 让索引号 乘以 44 就是每个li 的背景y坐标  index就是我们的y坐标
                                            var index = i * 44;
                                            lis[i].style.backgroundPosition = '0 -' + index + 'px';
                                        }
                                    </script>
                                </body>

                                
                             案例: 显示隐藏文本框内容

                                   当鼠标点击文本框时，里面的默认文字隐藏，当鼠标离开文本框时，里面的文字显示.

                                   案例分析:

                                   1. 首先表单需要2个新事件,获得焦点onfocus失去焦点onblur

                                   2. 如果获得焦点，判断表单里面内容是否为默认文字，如果是默认文字，就清空表单内容

                                        <head>
                                        <meta charset="UTF-8">
                                        <meta name="viewport" content="width=device-width, initial-scale=1.0">
                                        <meta http-equiv="X-UA-Compatible" content="ie=edge">
                                        <title>Document</title>
                                        <style>
                                            input {
                                                color: #999;
                                            }
                                        </style>
                                    </head>

                                    <body>
                                        <input type="text" value="手机">
                                        <script>
                                            // 1.获取元素
                                            var text = document.querySelector('input');
                                            // 2.注册事件 获得焦点事件 onfocus 
                                            text.onfocus = function() {
                                                    // console.log('得到了焦点');
                                                    if (this.value === '手机') {
                                                        this.value = '';
                                                    }
                                                    // 获得焦点需要把文本框里面的文字颜色变黑
                                                    this.style.color = '#333';
                                                }
                                                // 3. 注册事件 失去焦点事件 onblur
                                            text.onblur = function() {
                                                // console.log('失去了焦点');
                                                if (this.value === '') {
                                                    this.value = '手机';
                                                }
                                                // 失去焦点需要把文本框里面的文字颜色变浅色
                                                this.style.color = '#999';
                                            }
                                        </script>

                                    </body>


                             案例: 使用 className 修改样式属性
 
                                   1. 使用 element.style 获得修改元素样式 可以在样式比较少的情况下 或者 功能简单的情况下使用

                                   2. 但是在样式情况较多的情况下 就可以使用 className 来修改样式


                                    <head>
                                        <title>Document</title>
                                        <style>
                                            div {
                                                width: 100px;
                                                height: 100px;
                                                background-color: pink;
                                            }
                                            .change {
                                                background-color: purple;
                                                color: #fff;
                                                font-size: 25px;
                                                margin-top: 100px;
                                                //可以把修改的样式直接写到CSS里面,然后通过JS修改类名的方法来实现修改样式的效果
                                            }
                                        </style>
                                    </head>

                                    <body>
                                        <div class="first">文本</div>
                                        <script>
                                            var test = document.querySelector('div');
                                            test.onclick = function() {
                                                // 让我们当前元素的类名改为了 change

                                                // 1. 我们可以通过 修改元素的className更改元素的样式 适合于样式较多或者功能复杂的情况
                                                // 2. 因为class是一个保留字, 因此使用 className 来操作元素类名属性
                                                // 3. className 会直接更改元素的类名,会覆盖原先的类名 
                                                // 4. 如果想要保留原先的类名，我们可以使用<多类名选择器>
                                                this.className = 'first change';
                                            }
                                        </script>
                                    </body>


                             案例: 仿新浪注册页面

                                   当用户输入的密码不是6到16位,就提示 您输入的位数不对要求 6 ~ 16 位
                                   当用户输入的满足要求就提示输入正确

                                   <head>
                                    <title>Document</title>
                                    <style>
                                        div {
                                            width: 600px;
                                            margin: 100px auto;
                                        }                          
                                        .message {
                                            display: inline-block;
                                            font-size: 12px;
                                            color: #999;
                                            background: url(images/mess.png) no-repeat left center;
                                            padding-left: 20px;
                                        }                                       
                                        .wrong {
                                            color: red;
                                            background-image: url(images/wrong.png);
                                        }     
                                        .right {
                                            color: green;
                                            background-image: url(images/right.png);
                                        }
                                    </style>
                                </head>

                                <body>
                                    <div class="register">
                                        <input type="password" class="ipt">
                                        <p class="message">请输入6~16位密码</p>
                                    </div>
                                    <script>
                                        // 首先判断的事件是表单失去焦点 onblur
                                        // 如果输入正确则提示正确的信息颜色为绿色小图标变化
                                        // 如果输入不是6到16位，则提示错误信息颜色为红色 小图标变化
                                        // 因为里面变化样式较多，我们采取className修改样式
                                        // 1.获取元素
                                        var ipt = document.querySelector('.ipt');
                                        var message = document.querySelector('.message');
                                        //2. 注册事件 失去焦点
                                        ipt.onblur = function() {
                                            // 根据表单里面值的长度 ipt.value.length
                                            if (this.value.length < 6 || this.value.length > 16) {
                                                // console.log('错误');
                                                message.className = 'message wrong';
                                                message.innerHTML = '您输入的位数不对要求6~16位';
                                            } else {
                                                message.className = 'message right';
                                                message.innerHTML = '您输入的正确';
                                            }
                                        }
                                    </script>
                                </body>


                                案例: 排它思想 (算法) 









                1. BOM对象

                   1.1 什么是BOM

                      BOM (Browser Object Model)即浏览器对象模型, 它提供了独立于内容而与浏览器窗口进行交互的对象,其核心的对象是window

                      BOM 是由一系列相关的对象构成的,并且每个对象和属性都提供了很多的属性和方法

                      BOM 缺乏标准, JavaScript语法的标准化组织是ECMA,DOM的标准化组织是由W3C,BOM 最初由Netscape浏览器标准的一部分

                      1.2 DOM                                            

                         • 文档对象模型                                   
                         • DOM就是把文档当做一个对象来看待                
                         • DOM的顶级对象是document                       
                         • DOM主要学习的是操作页面元素                    
                         • DOM是W3C组织的标准规范
                         
                         BOM 
                         
                         • 浏览器对象模型
                         • 把浏览器当做一个对象来看待
                         • BOM的顶级对象是window
                         • BOM是浏览器厂商在各自浏览器上面去定义的,兼容性较差

                   1.3 BOM 的构成

                      window对象是浏览器的顶级对象,它具有双重角色

                      (1) 它是JS访问浏览器窗口的一个接口.

                      (2) 它是一个全局对象,定义在全局作用域,函数都会变成window对象的属性和方法

                      在调用的删号看一省略window,前面学习的对话框都属于window对象和方法,如alert(),prompt()等

                      注意:window下的一个特殊属性window.name


                2. window对象的常见的事件

                   2.1 窗口加载时间1

                      window.onload = function() {} 或者 window.addEeventListener("load", function() {});

                      window.onload 是窗口(页面)加载事件,当文档内容完全加载完成会触发该事件(包括图像,脚本文件,CSS文件等等,)就调用的处理函数

                      注意:
                          1. 有了window.onload 就可以吧JS代码写到页面元素的上方,因为onload是等页面内容完全加载完毕,再去执行处理函数

                          2. window.onload 传统注册事件方式只能写一次,如果有多个,会议最后一个window.onload为准.

                   2.2 窗口加载时间2

                     document.addEventlistenter('DOMContentLoaded', function () {})

                     DOMContentLoaded事件触发时, 仅当DOM加载完成,不包括样式,图片,flash等等.

                   2.3 调整窗口大小事件

                      window.onresize = function(){}
                      window.addEventlistener("resize", function(){});

                      window.onressize 是调整窗口大小时加载事件,当触发时就调用处理函数

                      注意:
                          
                          1. 只要窗口大小发生像素变化,就会触发这个事件.

                          2. 我们经常利用这个事件来完成响应式布局. window.innerWidth当前屏幕的宽度

                
                3. 定时器

                   3.1 两种定时器

                       window对象给我们提供了两种非常好用的方法 -- 定时器

                       ● setTimeout();

                       ● setInterval();

                   3.2 setTimeout() 定时器
                      
                       window.setTimeout(调用的函数, [延迟到毫秒数]);

                       setTimeout() 方法用于设置一个定时器,该定时器在定时器到期后执行调用函数

                       注意:

                           1. window 可以省略.
                           2. 这个调用函数可以直接写函数,或者写函数名或者采取字符串 '函数名()' 三种形式,但是第三种并不推荐
                           3. 延迟的毫秒数可以省略, 如果省略默认是0; 如果写的话,单位是毫秒,注意换算
                           4. 因为定时器可能很多,所以我们经常给定时器赋值一个标志符
                              例如:
                                  function bigbang() {
                                    console.log(大爆炸);
                                  }
                                  let time1 = setTimeout(bigbang, 30000);
                                  let time2 = setTimeout(bigbang, 50000);
                                  前面的函数名就是标志符,以便区分.


                   3.3 setTimeout() 定时器
                      
                       window.seTimeout(调用函数,[延迟的函数]);

                       setTimeout() 这个调用函数我们也称为回调函数callback
                       普通的函数是按照代码的顺序直接调用
                       但是这个函数需要等待时间,时间到了才会去调用这个函数,因此被称为回调函数
                       简单理解: 回调函数,就是回头调用的意思,上一件事情干完,回头再调用这个函数


                   3.4 setInterval() 定时器

                      window.setInterval(回调函数, [间隔的毫秒数]);

                      setInterval() 方法是重复调用一个函数,每隔一段时间,就会去调用一次函数

                      注意:
                            1. window 可以省略.
                            2. 这个调用函数可以直接写函数，或者写函数名或者采取字符串 '函数名()'  三种形式.
                            3. 间隔的毫秒数省略默认是 0,如果写,必须是毫秒,表示每隔多少毫秒就自动调用这个函数.
                            4. 因为定时器可能有很多，所以我们经常给定时器赋值一个标识符.
                            5. 第一次执行也是间隔毫秒数之后执行，之后每隔毫秒数就执行一次

                   3.5 停止setlnterval()定时器

                       window.clearlnterval(clearInterval的ID);

                       clearlnterval()方法取消了先前通过调用setlnterval建立的定时器

                       注意: 
                           
                            1. window可以省略.
                            2. 里面的参数就是定时器的标志符.

                   3.6 this 
                      
                       this的指向问题在函数确定的时候是确定不了的,只有在执行的时候才能确定this到底指向给了谁,一般情况下this的最终指向的都是哪个最终调用它的对象

                       现阶段,我们先了解一下几个this指向

                       1. 全局作用域或者普通函数中this指向全局对象window(注意定时器里面的this最终都会指向window)
                       2. 方法调用中谁调用了this就指向了谁
                       3. 构造函数中this指向构造函数的实例


                4. JS执行机制

                   4.1 JS是单线程

                       JavaScript语言的一大特点就是'单线程',也就是说,'同一时间只能做一件事',这是因为JavaScript这门脚本语言诞生的使命所导致--这是因为JavaScript这门脚本语言诞生的使命所导致--JavaScript是为了处理页面中用户的交互,以及操作DOM而诞生 比如我们对某个DOM元素进行添加和删除操作,不能同时进行,应该先添加,之后再删除

                       单线程就意味着,所有任务都需要排队,前一个任务结束才会执行下一个任务. 这样所导致的问题就是: 如果JS执行的时间过长,这样就会造成页面渲染不连贯,导致页面渲染加载阻塞的感觉.

                   4.2 JS的同步和异步

                       为了解决这个问题,利用多核CPU的计算能力,HTML5提出Web Worker标准,允许 JavaScript 脚本创建多个线程,于是JS中出现了同步和异步

                       同步:

                            前一个任务结束之后再去执行后一个任务, 程序的执行顺序与任务的排序顺序是一致的同步的.
                            比如做饭的同步做法:先烧水,等10分钟后水开了再去切菜,炒菜

                       异步: 
                            
                            你在做一件事情时，因为这件事情会花费很长时间，在做这件事的同时，你还可以去处理其他事情.比如做
                            饭的异步做法,我们在烧水的同时,利用这10分钟,去切菜,炒菜.
                            

                            '他们的本质区别: 这条流水线上各个流程的执行顺序不同'

                   4.3 JS的同步和异步任务

                        同步任务: 
                                
                                 同步任务都在主线程上执行，形成一个执行栈

                        异步任务:
                          
                                 JS 的异步是通过回调函数实现的
                                 一般而言，异步任务有以下三种类型: 
                                 1. 普通事件，如 click、resize 等 
                                 2. 资源加载，如 load、error 等 
                                 3. 定时器，包括 setInterval、setTimeout 等 
                                 异步任务相关回调函数添加到任务队列中（任务队列也称为消息队列）

                   4.4 JS 执行机制

                       1. 先执行执行栈中的同步任务. 
                       2. 异步任务(回调函数)放入任务队列中. 
                       3. 一旦执行栈中的所有同步任务执行完毕,系统就会按次序读取任务队列中的异步任务,于是被读取的异步任
                          务结束等待状态,进入执行栈,开始执行.

                5. location对象

                   5.1 什么是location

                       window对象给我们提供了一个 'location'属性用于获取或设置窗体的URL,并且用于解析URL.因为这个属性返回的是一个对象,所以我们也将这个属性称为location对象
                            
                   5.2 location对象的属性

                       'location对象                  返回值'

                       location.href            获取或者社会整个URL

                       location.host            返回主机(域名)

                       location.port            返回端口号 如果未写返回空的字符串

                       location.pathname        返回路径

                       location.search          返回参数

                       location.hash            返回片段 #后面的内容常见于连接或者锚点

                       重点记住: href 和 search

                       




                   

                  












                      













                                 





 

                                        

                                        


                                    
                                    


















                                                 









                                                 










 













                                            







                                       


                                       







                                        









                                         












                                       



                                       





                                       



                                        




                                   







                                         



                                 




















                                          
 






                                            

                                        





                                        


                                        
                                        



                                             

                                          





                               
                                
                             
                               



                                         











                                        





                               
                                 


                                   

                                      

 

    </body>
                  
</body>

</html>